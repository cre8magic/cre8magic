{
  "api/ToSic.Cre8magic.Act.IMagicAct.html": {
    "href": "api/ToSic.Cre8magic.Act.IMagicAct.html",
    "title": "Interface IMagicAct | cre8magic",
    "keywords": "Interface IMagicAct Namespace ToSic.Cre8magic.Act Assembly ToSic.Cre8magic.Client.Oqtane.dll This is the magic hat from which you can pull just about anything you can think of. public interface IMagicAct Methods AnalyticsKit(MagicAnalyticsSpell?) Get a kit to work with analytics. IMagicAnalyticsKit AnalyticsKit(MagicAnalyticsSpell? settings = null) Parameters settings MagicAnalyticsSpell Optional settings. If not provided, will try to automatically find the settings as configured in the Theme. Returns IMagicAnalyticsKit BreadcrumbKit(MagicBreadcrumbSpell?) Get the Kit to work with a Breadcrumb. It will either use the provided settings, retrieve these from the global information or use a default settings. IMagicBreadcrumbKit BreadcrumbKit(MagicBreadcrumbSpell? settings = null) Parameters settings MagicBreadcrumbSpell Returns IMagicBreadcrumbKit ContainerKit(MagicContainerSpell?) Get a kit to work with containers. IMagicContainerKit ContainerKit(MagicContainerSpell? settings = null) Parameters settings MagicContainerSpell Required; must provide the ModuleState as a property and usually the PageState (if not specified in the Theme) Returns IMagicContainerKit LanguageKit(MagicLanguageSpell?) Get the kit to work with languages. Must be async, because it might need to load async data from Oqtane. IMagicLanguageKit LanguageKit(MagicLanguageSpell? settings = null) Parameters settings MagicLanguageSpell Returns IMagicLanguageKit Link(MagicLinkSettings) Get a link based on the settings. string Link(MagicLinkSettings settings) Parameters settings MagicLinkSettings Settings to specify what link; if not provided, will currently return the link to the current page, but this may change. Returns string MenuKit(MagicMenuSpell?) Get the menu kit containing all items for the current page and specified settings. IMagicMenuKit MenuKit(MagicMenuSpell? settings = null) Parameters settings MagicMenuSpell Returns IMagicMenuKit PageContextKit(MagicPageContextSpell?) IMagicPageContextKit PageContextKit(MagicPageContextSpell? settings = null) Parameters settings MagicPageContextSpell Returns IMagicPageContextKit ThemeKit(MagicThemeSpell?) Get a theme kit for the current page, to customize the theme. IMagicThemeKit ThemeKit(MagicThemeSpell? settings = null) Parameters settings MagicThemeSpell The Settings; optional Returns IMagicThemeKit UsePageState(PageState) IMagicAct UsePageState(PageState pageState) Parameters pageState PageState Returns IMagicAct UseSettingsProvider(Func<IMagicSpellsProvider, IMagicSpellsProvider>) IMagicAct UseSettingsProvider(Func<IMagicSpellsProvider, IMagicSpellsProvider> providerFunc) Parameters providerFunc Func<IMagicSpellsProvider, IMagicSpellsProvider> Returns IMagicAct UseSpellsBook(MagicSpellsBook) IMagicAct UseSpellsBook(MagicSpellsBook book) Parameters book MagicSpellsBook Returns IMagicAct UseThemePackage(MagicThemePackage) IMagicAct UseThemePackage(MagicThemePackage themePackage) Parameters themePackage MagicThemePackage Returns IMagicAct User(MagicUserSpell?) MagicUser User(MagicUserSpell? settings = null) Parameters settings MagicUserSpell Returns MagicUser UserLoginKit(MagicUserLoginSpell?) IMagicUserLoginKit UserLoginKit(MagicUserLoginSpell? settings = null) Parameters settings MagicUserLoginSpell Returns IMagicUserLoginKit"
  },
  "api/ToSic.Cre8magic.Act.html": {
    "href": "api/ToSic.Cre8magic.Act.html",
    "title": "Cre8magic Act - the starting of any amazing performance on Oqtane | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Act The starting point for your code. Contains the MagicAct and more. The Starting Act of Your Amazing Oqtane Performance This is the entry-point namespace for any great work with Cre8magic. It contains the MagicAct which is the main entry-point for all of your magic. Interfaces IMagicAct This is the magic hat from which you can pull just about anything you can think of."
  },
  "api/ToSic.Cre8magic.Analytics.IMagicAnalyticsKit.html": {
    "href": "api/ToSic.Cre8magic.Analytics.IMagicAnalyticsKit.html",
    "title": "Interface IMagicAnalyticsKit | cre8magic",
    "keywords": "Interface IMagicAnalyticsKit Namespace ToSic.Cre8magic.Analytics Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface IMagicAnalyticsKit Properties Spell MagicAnalyticsSpell Spell { get; init; } Property Value MagicAnalyticsSpell Methods TrackPage(bool) Simplest way to track a page, assumes that the settings are injected from a Settings Source. Will take the PageState and - depending on the settings - track the view in Google Analytics. Must run in OnAfterRenderAsync for now Task TrackPage(bool isFirstRender) Parameters isFirstRender bool Returns Task"
  },
  "api/ToSic.Cre8magic.Analytics.MagicAnalyticsSpell.html": {
    "href": "api/ToSic.Cre8magic.Analytics.MagicAnalyticsSpell.html",
    "title": "Class MagicAnalyticsSpell | cre8magic",
    "keywords": "Class MagicAnalyticsSpell Namespace ToSic.Cre8magic.Analytics Assembly ToSic.Cre8magic.Client.Oqtane.dll Settings to set up and use Google Tag Manager to track page views. BETA: Doesn't completely work yet. Main caveat: Integration of the Google Tag Manager still has the GTM hardwired in the JS, must be finished. Background is that the Module currently doesn't contain its own JS, so it's still part of the theme. public record MagicAnalyticsSpell : MagicSpellBase Inheritance object MagicInheritsBase MagicSpellBase MagicAnalyticsSpell Inherited Members MagicSpellBase.PageState MagicSpellBase.Name MagicSpellBase.Debug MagicInheritsBase.Inherits Extension Methods MagicSpellExtensions.Refill<TSpell>(TSpell?, PageState) MagicSpellExtensions.Refill<TSpell, TWith>(TSpell?, TWith?) MagicSpellExtensions.With<TSpell>(TSpell?, PageState, string?) MagicSpellExtensions.With<TSpell, TWith>(TSpell?, TWith?) Properties GtmId ID of Google Tag Manager. public string? GtmId { get; init; } Property Value string PageViewEvent Name of the event to give to GTM which should be logged. Defaults to \"blazor_page_view\". public string? PageViewEvent { get; init; } Property Value string PageViewJs JavaScript function to call for tracking page views. Defaults to \"gtag\". public string? PageViewJs { get; init; } Property Value string PageViewTrack public bool? PageViewTrack { get; init; } Property Value bool? PageViewTrackFirst public bool? PageViewTrackFirst { get; init; } Property Value bool?"
  },
  "api/ToSic.Cre8magic.Analytics.html": {
    "href": "api/ToSic.Cre8magic.Analytics.html",
    "title": "Namespace ToSic.Cre8magic.Analytics | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Analytics Classes MagicAnalyticsSpell Settings to set up and use Google Tag Manager to track page views. BETA: Doesn't completely work yet. Main caveat: Integration of the Google Tag Manager still has the GTM hardwired in the JS, must be finished. Background is that the Module currently doesn't contain its own JS, so it's still part of the theme. Interfaces IMagicAnalyticsKit"
  },
  "api/ToSic.Cre8magic.Breadcrumbs.IMagicBreadcrumbKit.html": {
    "href": "api/ToSic.Cre8magic.Breadcrumbs.IMagicBreadcrumbKit.html",
    "title": "Interface IMagicBreadcrumbKit | cre8magic",
    "keywords": "Interface IMagicBreadcrumbKit Namespace ToSic.Cre8magic.Breadcrumbs Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface IMagicBreadcrumbKit Properties Pages Pages to show in the breadcrumb, as specified by the settings. IEnumerable<IMagicPage> Pages { get; } Property Value IEnumerable<IMagicPage> Root Virtual \"root\" page of the breadcrumb, mainly for styling things around the real breadcrumb. IMagicPage Root { get; } Property Value IMagicPage Show Information if this Breadcrumb should be shown according to configuration. The code must decide if it respects this or not. bool Show { get; } Property Value bool"
  },
  "api/ToSic.Cre8magic.Breadcrumbs.MagicBreadcrumbBlueprint.html": {
    "href": "api/ToSic.Cre8magic.Breadcrumbs.MagicBreadcrumbBlueprint.html",
    "title": "Class MagicBreadcrumbBlueprint | cre8magic",
    "keywords": "Class MagicBreadcrumbBlueprint Namespace ToSic.Cre8magic.Breadcrumbs Assembly ToSic.Cre8magic.Client.Oqtane.dll Language Design Settings public record MagicBreadcrumbBlueprint : MagicBlueprint Inheritance object MagicInheritsBase MagicBlueprint MagicBreadcrumbBlueprint Inherited Members MagicBlueprint.Parts MagicInheritsBase.Inherits"
  },
  "api/ToSic.Cre8magic.Breadcrumbs.MagicBreadcrumbSpell.html": {
    "href": "api/ToSic.Cre8magic.Breadcrumbs.MagicBreadcrumbSpell.html",
    "title": "Class MagicBreadcrumbSpell | cre8magic",
    "keywords": "Class MagicBreadcrumbSpell Namespace ToSic.Cre8magic.Breadcrumbs Assembly ToSic.Cre8magic.Client.Oqtane.dll Breadcrumb settings - either provided in code, or generated from JSON. public record MagicBreadcrumbSpell : MagicSpellBase, IMagicPageSetSettings Inheritance object MagicInheritsBase MagicSpellBase MagicBreadcrumbSpell Implements IMagicPageSetSettings Inherited Members MagicSpellBase.PageState MagicSpellBase.Name MagicSpellBase.Debug MagicInheritsBase.Inherits Extension Methods MagicSpellExtensions.Refill<TSpell>(TSpell?, PageState) MagicSpellExtensions.Refill<TSpell, TWith>(TSpell?, TWith?) MagicSpellExtensions.With<TSpell>(TSpell?, PageState, string?) MagicSpellExtensions.With<TSpell, TWith>(TSpell?, TWith?) Remarks NOTE that as of v0.2 the JSON variant is not in use. Properties Active [JsonIgnore] public IMagicPage? Active { get; init; } Property Value IMagicPage ActiveId Start page of this breadcrumb - like home or another specific page. Can be a specific ID blank / null, current page public int? ActiveId { get; init; } Property Value int? Blueprint [JsonIgnore] public MagicBreadcrumbBlueprint? Blueprint { get; init; } Property Value MagicBreadcrumbBlueprint Id A unique ID to identify the breadcrumb. public string? Id { get; init; } Property Value string MaxDepth Maximum depth of the breadcrumb, defaults to 10. This is to ensure that we don't run into infinite loops. [JsonIgnore] public int MaxDepth { get; init; } Property Value int MenuId Menu ID for use in JavaScript etc. Usually predefined OR a random number public string MenuId { get; } Property Value string Pages List of pages to respect when creating the breadcrumb. Default is null - so it will just take all the pages. TODO: NAMING [JsonIgnore] public IEnumerable<IMagicPage>? Pages { get; init; } Property Value IEnumerable<IMagicPage> Reverse If the order of the Breadcrumb should be reversed. [JsonIgnore] public bool? Reverse { get; init; } Property Value bool? Show Determines if this breadcrumb should be shown. public bool? Show { get; init; } Property Value bool? Tailor [JsonIgnore] public IMagicPageTailor? Tailor { get; init; } Property Value IMagicPageTailor Variant public string? Variant { get; init; } Property Value string WithActive If the current page should be included in the breadcrumb. Set to false for scenarios where you don't want to show the final page, or will use custom code to visualize differently. [JsonIgnore] public bool? WithActive { get; init; } Property Value bool? WithHome If the home page should be included in the breadcrumb. This is special because the home page is usually not really \"above\" the others, but typically side-by side to other pages on the top level menu. Set to false, if you only want to show the breadcrumb starting at the level below home. [JsonIgnore] public bool? WithHome { get; init; } Property Value bool?"
  },
  "api/ToSic.Cre8magic.Breadcrumbs.MagicBreadcrumbTailor.html": {
    "href": "api/ToSic.Cre8magic.Breadcrumbs.MagicBreadcrumbTailor.html",
    "title": "Class MagicBreadcrumbTailor | cre8magic",
    "keywords": "Class MagicBreadcrumbTailor Namespace ToSic.Cre8magic.Breadcrumbs Assembly ToSic.Cre8magic.Client.Oqtane.dll Special helper to provide Css classes to menus public class MagicBreadcrumbTailor : IMagicPageTailor Inheritance object MagicBreadcrumbTailor Implements IMagicPageTailor Methods Classes(string, IMagicPage) public string Classes(string tag, IMagicPage item) Parameters tag string item IMagicPage Returns string Value(string, IMagicPage) public string Value(string key, IMagicPage item) Parameters key string item IMagicPage Returns string"
  },
  "api/ToSic.Cre8magic.Breadcrumbs.MagicBreadcrumbTailorBs5.html": {
    "href": "api/ToSic.Cre8magic.Breadcrumbs.MagicBreadcrumbTailorBs5.html",
    "title": "Class MagicBreadcrumbTailorBs5 | cre8magic",
    "keywords": "Class MagicBreadcrumbTailorBs5 Namespace ToSic.Cre8magic.Breadcrumbs Assembly ToSic.Cre8magic.Client.Oqtane.dll Default designer for breadcrumbs in Bootstrap 5. Will use the standard Bootstrap 5 classes for breadcrumbs. ol: breadcrumb li: breadcrumb-item active state: \"active\" public class MagicBreadcrumbTailorBs5 : MagicPageTailorBasic, IMagicPageTailor Inheritance object MagicPageTailorBase MagicPageTailorBasic MagicBreadcrumbTailorBs5 Implements IMagicPageTailor Inherited Members MagicPageTailorBasic.All MagicPageTailorBasic.LookupClasses MagicPageTailorBasic.LookupClassActive MagicPageTailorBasic.Classes(string, IMagicPage) MagicPageTailorBasic.LookupData MagicPageTailorBasic.Value(string, IMagicPage) Constructors MagicBreadcrumbTailorBs5() public MagicBreadcrumbTailorBs5()"
  },
  "api/ToSic.Cre8magic.Breadcrumbs.html": {
    "href": "api/ToSic.Cre8magic.Breadcrumbs.html",
    "title": "Namespace ToSic.Cre8magic.Breadcrumbs | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Breadcrumbs Classes MagicBreadcrumbBlueprint Language Design Settings MagicBreadcrumbSpell Breadcrumb settings - either provided in code, or generated from JSON. MagicBreadcrumbTailor Special helper to provide Css classes to menus MagicBreadcrumbTailorBs5 Default designer for breadcrumbs in Bootstrap 5. Will use the standard Bootstrap 5 classes for breadcrumbs. ol: breadcrumb li: breadcrumb-item active state: \"active\" Interfaces IMagicBreadcrumbKit"
  },
  "api/ToSic.Cre8magic.Containers.IMagicContainerKit.html": {
    "href": "api/ToSic.Cre8magic.Containers.IMagicContainerKit.html",
    "title": "Interface IMagicContainerKit | cre8magic",
    "keywords": "Interface IMagicContainerKit Namespace ToSic.Cre8magic.Containers Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface IMagicContainerKit Properties IsForAdminModule Modules are treated as admin modules (and must use the admin container) if they are marked as such, or come from the Oqtane ....Admin... type bool IsForAdminModule { get; } Property Value bool Tailor MagicContainerTailor Tailor { get; init; } Property Value MagicContainerTailor"
  },
  "api/ToSic.Cre8magic.Containers.MagicContainerBlueprint.html": {
    "href": "api/ToSic.Cre8magic.Containers.MagicContainerBlueprint.html",
    "title": "Class MagicContainerBlueprint | cre8magic",
    "keywords": "Class MagicContainerBlueprint Namespace ToSic.Cre8magic.Containers Assembly ToSic.Cre8magic.Client.Oqtane.dll public record MagicContainerBlueprint : MagicBlueprint Inheritance object MagicInheritsBase MagicBlueprint MagicContainerBlueprint Inherited Members MagicBlueprint.Parts MagicInheritsBase.Inherits"
  },
  "api/ToSic.Cre8magic.Containers.MagicContainerSpell.html": {
    "href": "api/ToSic.Cre8magic.Containers.MagicContainerSpell.html",
    "title": "Class MagicContainerSpell | cre8magic",
    "keywords": "Class MagicContainerSpell Namespace ToSic.Cre8magic.Containers Assembly ToSic.Cre8magic.Client.Oqtane.dll public record MagicContainerSpell : MagicSpellBase Inheritance object MagicInheritsBase MagicSpellBase MagicContainerSpell Inherited Members MagicSpellBase.PageState MagicSpellBase.Name MagicSpellBase.Debug MagicInheritsBase.Inherits Extension Methods MagicSpellExtensions.Refill<TSpell>(TSpell?, PageState) MagicSpellExtensions.Refill<TSpell, TWith>(TSpell?, TWith?) MagicSpellExtensions.With<TSpell>(TSpell?, PageState, string?) MagicSpellExtensions.With<TSpell, TWith>(TSpell?, TWith?) Properties Blueprint [JsonIgnore] public MagicContainerBlueprint? Blueprint { get; init; } Property Value MagicContainerBlueprint ModuleState public Module? ModuleState { get; init; } Property Value Module"
  },
  "api/ToSic.Cre8magic.Containers.MagicContainerTailor.html": {
    "href": "api/ToSic.Cre8magic.Containers.MagicContainerTailor.html",
    "title": "Class MagicContainerTailor | cre8magic",
    "keywords": "Class MagicContainerTailor Namespace ToSic.Cre8magic.Containers Assembly ToSic.Cre8magic.Client.Oqtane.dll public class MagicContainerTailor : MagicTailorBase, IMagicTailor Inheritance object MagicTailorBase MagicContainerTailor Implements IMagicTailor Inherited Members MagicTailorBase.Parts MagicTailorBase.GetSettings(string) MagicTailorBase.ParseTokens MagicTailorBase.ProcessTokens(string) MagicTailorBase.Value(string) MagicTailorBase.Id(string) Methods Classes(string) public override string? Classes(string tag) Parameters tag string Returns string"
  },
  "api/ToSic.Cre8magic.Containers.html": {
    "href": "api/ToSic.Cre8magic.Containers.html",
    "title": "Namespace ToSic.Cre8magic.Containers | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Containers Classes MagicContainerBlueprint MagicContainerSpell MagicContainerTailor Interfaces IMagicContainerKit"
  },
  "api/ToSic.Cre8magic.Languages.IMagicLanguageKit.html": {
    "href": "api/ToSic.Cre8magic.Languages.IMagicLanguageKit.html",
    "title": "Interface IMagicLanguageKit | cre8magic",
    "keywords": "Interface IMagicLanguageKit Namespace ToSic.Cre8magic.Languages Assembly ToSic.Cre8magic.Client.Oqtane.dll The Kit to Show language menus in the UI. You can get it by @inject / [Inject]-ing the IMagicAct and calling the LanguageKit(MagicLanguageSpell?). public interface IMagicLanguageKit Properties Languages List of languages to show as specified in the settings. IEnumerable<MagicLanguage> Languages { get; init; } Property Value IEnumerable<MagicLanguage> Show Determines if the languages should be shown. Will be retrieved from the settings bool Show { get; init; } Property Value bool Spell MagicLanguageSpell Spell { get; init; } Property Value MagicLanguageSpell Tailor MagicLanguageTailor Tailor { get; init; } Property Value MagicLanguageTailor Methods SetCultureAsync(string) Command to set the culture. This will trigger a page reload. Task SetCultureAsync(string culture) Parameters culture string Returns Task"
  },
  "api/ToSic.Cre8magic.Languages.MagicLanguage.html": {
    "href": "api/ToSic.Cre8magic.Languages.MagicLanguage.html",
    "title": "Class MagicLanguage | cre8magic",
    "keywords": "Class MagicLanguage Namespace ToSic.Cre8magic.Languages Assembly ToSic.Cre8magic.Client.Oqtane.dll Describes a language inside Oqtane. With Name, Label, Culture and Active-State. public record MagicLanguage Inheritance object MagicLanguage Properties Culture public string Culture { get; init; } Property Value string Description Description to show for this language. Will auto-default to the system name for this language. public string? Description { get; init; } Property Value string IsActive public bool IsActive { get; } Property Value bool Label Label to show for this culture. Will auto-default to first two characters. public string? Label { get; init; } Property Value string"
  },
  "api/ToSic.Cre8magic.Languages.MagicLanguageBlueprint.html": {
    "href": "api/ToSic.Cre8magic.Languages.MagicLanguageBlueprint.html",
    "title": "Class MagicLanguageBlueprint | cre8magic",
    "keywords": "Class MagicLanguageBlueprint Namespace ToSic.Cre8magic.Languages Assembly ToSic.Cre8magic.Client.Oqtane.dll Language Design Settings public record MagicLanguageBlueprint : MagicBlueprint Inheritance object MagicInheritsBase MagicBlueprint MagicLanguageBlueprint Inherited Members MagicBlueprint.Parts MagicInheritsBase.Inherits"
  },
  "api/ToSic.Cre8magic.Languages.MagicLanguageSpell.html": {
    "href": "api/ToSic.Cre8magic.Languages.MagicLanguageSpell.html",
    "title": "Class MagicLanguageSpell | cre8magic",
    "keywords": "Class MagicLanguageSpell Namespace ToSic.Cre8magic.Languages Assembly ToSic.Cre8magic.Client.Oqtane.dll public record MagicLanguageSpell : MagicSpellBase Inheritance object MagicInheritsBase MagicSpellBase MagicLanguageSpell Inherited Members MagicSpellBase.PageState MagicSpellBase.Name MagicSpellBase.Debug MagicInheritsBase.Inherits Extension Methods MagicSpellExtensions.Refill<TSpell>(TSpell?, PageState) MagicSpellExtensions.Refill<TSpell, TWith>(TSpell?, TWith?) MagicSpellExtensions.With<TSpell>(TSpell?, PageState, string?) MagicSpellExtensions.With<TSpell, TWith>(TSpell?, TWith?) Properties Blueprint [JsonIgnore] public MagicLanguageBlueprint? Blueprint { get; init; } Property Value MagicLanguageBlueprint HideOthers If true, will only show the languages which are explicitly configured. If false, will first show the configured languages, then the rest. public bool? HideOthers { get; init; } Property Value bool? Languages List of languages [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicLanguage>))] public Dictionary<string, MagicLanguage>? Languages { get; init; } Property Value Dictionary<string, MagicLanguage> MinLanguagesToShow public int MinLanguagesToShow { get; init; } Property Value int"
  },
  "api/ToSic.Cre8magic.Languages.MagicLanguageTailor.html": {
    "href": "api/ToSic.Cre8magic.Languages.MagicLanguageTailor.html",
    "title": "Class MagicLanguageTailor | cre8magic",
    "keywords": "Class MagicLanguageTailor Namespace ToSic.Cre8magic.Languages Assembly ToSic.Cre8magic.Client.Oqtane.dll public class MagicLanguageTailor : MagicTailorBase, IMagicTailor Inheritance object MagicTailorBase MagicLanguageTailor Implements IMagicTailor Inherited Members MagicTailorBase.Parts MagicTailorBase.GetSettings(string) MagicTailorBase.ParseTokens MagicTailorBase.ProcessTokens(string) MagicTailorBase.Classes(string) MagicTailorBase.Value(string) MagicTailorBase.Id(string) Methods Classes(string, MagicLanguage?) TODO: PROBABLY MOVE TO Language? public string Classes(string tag, MagicLanguage? lang) Parameters tag string lang MagicLanguage Returns string"
  },
  "api/ToSic.Cre8magic.Languages.html": {
    "href": "api/ToSic.Cre8magic.Languages.html",
    "title": "Namespace ToSic.Cre8magic.Languages | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Languages Classes MagicLanguage Describes a language inside Oqtane. With Name, Label, Culture and Active-State. MagicLanguageBlueprint Language Design Settings MagicLanguageSpell MagicLanguageTailor Interfaces IMagicLanguageKit The Kit to Show language menus in the UI. You can get it by @inject / [Inject]-ing the IMagicAct and calling the LanguageKit(MagicLanguageSpell?)."
  },
  "api/ToSic.Cre8magic.Links.IMagicLinkService.html": {
    "href": "api/ToSic.Cre8magic.Links.IMagicLinkService.html",
    "title": "Interface IMagicLinkService | cre8magic",
    "keywords": "Interface IMagicLinkService Namespace ToSic.Cre8magic.Links Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface IMagicLinkService Methods Link(PageState, MagicLinkSettings?) Get a link based on the settings. string Link(PageState pageState, MagicLinkSettings? settings = null) Parameters pageState PageState settings MagicLinkSettings Settings to specify what link; if not provided, will currently return the link to the current page, but this may change. Returns string"
  },
  "api/ToSic.Cre8magic.Links.MagicLinkSettings.html": {
    "href": "api/ToSic.Cre8magic.Links.MagicLinkSettings.html",
    "title": "Class MagicLinkSettings | cre8magic",
    "keywords": "Class MagicLinkSettings Namespace ToSic.Cre8magic.Links Assembly ToSic.Cre8magic.Client.Oqtane.dll public record MagicLinkSettings : MagicSpellBase Inheritance object MagicInheritsBase MagicSpellBase MagicLinkSettings Inherited Members MagicSpellBase.PageState MagicSpellBase.Name MagicSpellBase.Debug MagicInheritsBase.Inherits Extension Methods MagicSpellExtensions.Refill<TSpell>(TSpell?, PageState) MagicSpellExtensions.Refill<TSpell, TWith>(TSpell?, TWith?) MagicSpellExtensions.With<TSpell>(TSpell?, PageState, string?) MagicSpellExtensions.With<TSpell, TWith>(TSpell?, TWith?) Properties Path public string? Path { get; init; } Property Value string QueryString public string? QueryString { get; init; } Property Value string"
  },
  "api/ToSic.Cre8magic.Links.html": {
    "href": "api/ToSic.Cre8magic.Links.html",
    "title": "Namespace ToSic.Cre8magic.Links | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Links Classes MagicLinkSettings Interfaces IMagicLinkService"
  },
  "api/ToSic.Cre8magic.MagicConstants.html": {
    "href": "api/ToSic.Cre8magic.MagicConstants.html",
    "title": "Class MagicConstants | cre8magic",
    "keywords": "Class MagicConstants Namespace ToSic.Cre8magic Assembly ToSic.Cre8magic.Client.Oqtane.dll public class MagicConstants Inheritance object MagicConstants Fields Default public static string Default Field Value string DesignMobile public static string DesignMobile Field Value string MenuHorizontal public const string MenuHorizontal = \"Horizontal\" Field Value string MenuVertical public const string MenuVertical = \"Vertical\" Field Value string PackageId public const string PackageId = \"ToSic.Cre8magic.Oqtane\" Field Value string"
  },
  "api/ToSic.Cre8magic.MagicTokens.html": {
    "href": "api/ToSic.Cre8magic.MagicTokens.html",
    "title": "Class MagicTokens | cre8magic",
    "keywords": "Class MagicTokens Namespace ToSic.Cre8magic Assembly ToSic.Cre8magic.Client.Oqtane.dll public class MagicTokens Inheritance object MagicTokens"
  },
  "api/ToSic.Cre8magic.Menus.IMagicMenuKit.html": {
    "href": "api/ToSic.Cre8magic.Menus.IMagicMenuKit.html",
    "title": "Interface IMagicMenuKit | cre8magic",
    "keywords": "Interface IMagicMenuKit Namespace ToSic.Cre8magic.Menus Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface IMagicMenuKit Properties Root The root node to start from. This behaves like a IMagicPage but is not really a page. It does provide Children and can also do design work like apply Classes, typically to the outermost <ul></ul> tags etc. IMagicPage Root { get; init; } Property Value IMagicPage Spell The settings used to retrieve and build the pages. MagicMenuSpell Spell { get; } Property Value MagicMenuSpell Variant The menu variant to use. Usually determined by the settings. string Variant { get; } Property Value string Methods IsVariant(string) Check if the menu is of a specific variant. Case-insensitive. bool IsVariant(string variant) Parameters variant string the variant to check, like \"vertical\" Returns bool"
  },
  "api/ToSic.Cre8magic.Menus.MagicMenuBlueprint.html": {
    "href": "api/ToSic.Cre8magic.Menus.MagicMenuBlueprint.html",
    "title": "Class MagicMenuBlueprint | cre8magic",
    "keywords": "Class MagicMenuBlueprint Namespace ToSic.Cre8magic.Menus Assembly ToSic.Cre8magic.Client.Oqtane.dll Menu Design Settings public record MagicMenuBlueprint : MagicBlueprint Inheritance object MagicInheritsBase MagicBlueprint MagicMenuBlueprint Inherited Members MagicBlueprint.Parts MagicInheritsBase.Inherits"
  },
  "api/ToSic.Cre8magic.Menus.MagicMenuSpell.html": {
    "href": "api/ToSic.Cre8magic.Menus.MagicMenuSpell.html",
    "title": "Class MagicMenuSpell | cre8magic",
    "keywords": "Class MagicMenuSpell Namespace ToSic.Cre8magic.Menus Assembly ToSic.Cre8magic.Client.Oqtane.dll The raw settings for a menu, in a way which can be stored elsewhere. This is later augmented with additional information which only code can provide, in the MagicMenuSpell public record MagicMenuSpell : MagicSpellBase, IMagicPageSetSettings Inheritance object MagicInheritsBase MagicSpellBase MagicMenuSpell Implements IMagicPageSetSettings Inherited Members MagicSpellBase.PageState MagicSpellBase.Name MagicSpellBase.Debug MagicInheritsBase.Inherits Extension Methods MagicSpellExtensions.Refill<TSpell>(TSpell?, PageState) MagicSpellExtensions.Refill<TSpell, TWith>(TSpell?, TWith?) MagicSpellExtensions.With<TSpell>(TSpell?, PageState, string?) MagicSpellExtensions.With<TSpell, TWith>(TSpell?, TWith?) Remarks This is implemented as an immutable record. Properties Blueprint [JsonIgnore] public MagicMenuBlueprint? Blueprint { get; init; } Property Value MagicMenuBlueprint Id A unique ID to identify the menu. Would be used for debugging but also to help in creating unique css-classes for collapsible menus public string? Id { get; init; } Property Value string MenuId Menu ID for use in JavaScript etc. Usually predefined OR a random number public string MenuId { get; } Property Value string PagesSource List of pages to respect when creating the breadcrumb. Default is null - so it will just take all the pages. TODO: NAMING [JsonIgnore] public IEnumerable<IMagicPage>? PagesSource { get; init; } Property Value IEnumerable<IMagicPage> Pick Start page of this navigation - like home or another specific page. Can be a specific ID a CSV of IDs ??? * to indicate all pages on the specified level . to indicate current page blank / null, to use another start ??? public string? Pick { get; init; } Property Value string Show Determines if this navigation should be shown. Mainly used for standard menus which could be disabled through settings. public bool? Show { get; init; } Property Value bool? Tailor [JsonIgnore] public IMagicPageTailor? Tailor { get; init; } Property Value IMagicPageTailor Variant The menu variant to use, for example horizontal or vertical. Will only have an effect if the control showing the menu supports it. public string? Variant { get; init; } Property Value string"
  },
  "api/ToSic.Cre8magic.Menus.html": {
    "href": "api/ToSic.Cre8magic.Menus.html",
    "title": "Namespace ToSic.Cre8magic.Menus | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Menus Classes MagicMenuBlueprint Menu Design Settings MagicMenuSpell The raw settings for a menu, in a way which can be stored elsewhere. This is later augmented with additional information which only code can provide, in the MagicMenuSpell Interfaces IMagicMenuKit"
  },
  "api/ToSic.Cre8magic.OqtaneBs5.Debug.MagicDebug.html": {
    "href": "api/ToSic.Cre8magic.OqtaneBs5.Debug.MagicDebug.html",
    "title": "Class MagicDebug | cre8magic",
    "keywords": "Class MagicDebug Namespace ToSic.Cre8magic.OqtaneBs5.Debug Assembly ToSic.Cre8Magic.OqtaneBs5.Client.Oqtane.dll public class MagicDebug : ComponentBase Inheritance object ComponentBase MagicDebug Properties PageState [CascadingParameter] public required PageState PageState { get; set; } Property Value PageState Target [Parameter] [EditorRequired] public required IHasDebugInfo Target { get; set; } Property Value IHasDebugInfo"
  },
  "api/ToSic.Cre8magic.OqtaneBs5.Debug.html": {
    "href": "api/ToSic.Cre8magic.OqtaneBs5.Debug.html",
    "title": "Namespace ToSic.Cre8magic.OqtaneBs5.Debug | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.OqtaneBs5.Debug Classes MagicDebug"
  },
  "api/ToSic.Cre8magic.OqtaneBs5.MagicContainer.html": {
    "href": "api/ToSic.Cre8magic.OqtaneBs5.MagicContainer.html",
    "title": "Class MagicContainer | cre8magic",
    "keywords": "Class MagicContainer Namespace ToSic.Cre8magic.OqtaneBs5 Assembly ToSic.Cre8Magic.OqtaneBs5.Client.Oqtane.dll The recommended base container for all themes which use cre8magic. It will simply remain invisible for the normal user, and except for a DIV containing some classes, it will not render anything. Admin-users will see a bit more, since the title etc. is necessary for the editing tools. public class MagicContainer : ComponentBase Inheritance object ComponentBase MagicContainer Properties CloseUrl public string CloseUrl { get; } Property Value string ContainerKit some comments protected IMagicContainerKit ContainerKit { get; } Property Value IMagicContainerKit MagicAct [Inject] public required IMagicAct MagicAct { get; set; } Property Value IMagicAct ModuleState [CascadingParameter] public required Module ModuleState { get; set; } Property Value Module Name Visible name in the UI (unless overridden again in the inheriting container) public string Name { get; } Property Value string PageState [CascadingParameter] public required PageState PageState { get; set; } Property Value PageState Settings Settings for this container. Defaults to null, in which case it asks the theme etc. for settings. Inheriting code could overwrite it, to specify settings directly. public virtual MagicContainerSpell? Settings { get; } Property Value MagicContainerSpell Methods OnParametersSet() This should update the URL. But it only works on the \"first\" popup-dialog, anything after that will have a real url in the path and will actually just point to the same page. TODO: figure out a better way to remember the way back... protected override void OnParametersSet()"
  },
  "api/ToSic.Cre8magic.OqtaneBs5.MagicExceptions.html": {
    "href": "api/ToSic.Cre8magic.OqtaneBs5.MagicExceptions.html",
    "title": "Class MagicExceptions | cre8magic",
    "keywords": "Class MagicExceptions Namespace ToSic.Cre8magic.OqtaneBs5 Assembly ToSic.Cre8Magic.OqtaneBs5.Client.Oqtane.dll public class MagicExceptions : ComponentBase Inheritance object ComponentBase MagicExceptions Properties PageState The PageState containing the current page, list of all pages, user, etc. It will be injected by Blazor when the component is initialized using [CascadingParameter]. In most cases, this PageState is all you need. [CascadingParameter] public required PageState PageState { get; set; } Property Value PageState"
  },
  "api/ToSic.Cre8magic.OqtaneBs5.MagicLanguageMenu.html": {
    "href": "api/ToSic.Cre8magic.OqtaneBs5.MagicLanguageMenu.html",
    "title": "Class MagicLanguageMenu | cre8magic",
    "keywords": "Class MagicLanguageMenu Namespace ToSic.Cre8magic.OqtaneBs5 Assembly ToSic.Cre8Magic.OqtaneBs5.Client.Oqtane.dll public class MagicLanguageMenu : ComponentBase Inheritance object ComponentBase MagicLanguageMenu Properties PageState [CascadingParameter] public required PageState PageState { get; set; } Property Value PageState Settings [Parameter] public MagicLanguageSpell? Settings { get; set; } Property Value MagicLanguageSpell"
  },
  "api/ToSic.Cre8magic.OqtaneBs5.MagicMenu.html": {
    "href": "api/ToSic.Cre8magic.OqtaneBs5.MagicMenu.html",
    "title": "Class MagicMenu | cre8magic",
    "keywords": "Class MagicMenu Namespace ToSic.Cre8magic.OqtaneBs5 Assembly ToSic.Cre8Magic.OqtaneBs5.Client.Oqtane.dll public class MagicMenu : ComponentBase Inheritance object ComponentBase MagicMenu Properties Name [Parameter] public string? Name { get; set; } Property Value string PageState The PageState containing the current page, list of all pages, user, etc. It will be injected by Blazor when the component is initialized using [CascadingParameter]. In most cases, this PageState is all you need. [CascadingParameter] public required PageState PageState { get; set; } Property Value PageState Settings All the menu settings. If not provided, it will use the default settings from any other configuration. If provided, it may still merge these with other settings (like in PartName was specified). [Parameter] public MagicMenuSpell? Settings { get; set; } Property Value MagicMenuSpell"
  },
  "api/ToSic.Cre8magic.OqtaneBs5.MagicOqtaneControlPanel.html": {
    "href": "api/ToSic.Cre8magic.OqtaneBs5.MagicOqtaneControlPanel.html",
    "title": "Class MagicOqtaneControlPanel | cre8magic",
    "keywords": "Class MagicOqtaneControlPanel Namespace ToSic.Cre8magic.OqtaneBs5 Assembly ToSic.Cre8Magic.OqtaneBs5.Client.Oqtane.dll public class MagicOqtaneControlPanel : ComponentBase Inheritance object ComponentBase MagicOqtaneControlPanel Properties PageState The PageState containing the current page, list of all pages, user, etc. It will be injected by Blazor when the component is initialized using [CascadingParameter]. In most cases, this PageState is all you need. [CascadingParameter] public required PageState PageState { get; set; } Property Value PageState"
  },
  "api/ToSic.Cre8magic.OqtaneBs5.html": {
    "href": "api/ToSic.Cre8magic.OqtaneBs5.html",
    "title": "Namespace ToSic.Cre8magic.OqtaneBs5 | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.OqtaneBs5 Namespaces ToSic.Cre8magic.OqtaneBs5.Debug Classes MagicContainer The recommended base container for all themes which use cre8magic. It will simply remain invisible for the normal user, and except for a DIV containing some classes, it will not render anything. Admin-users will see a bit more, since the title etc. is necessary for the editing tools. MagicExceptions MagicLanguageMenu MagicMenu MagicOqtaneControlPanel"
  },
  "api/ToSic.Cre8magic.PageContexts.IMagicPageContextKit.html": {
    "href": "api/ToSic.Cre8magic.PageContexts.IMagicPageContextKit.html",
    "title": "Interface IMagicPageContextKit | cre8magic",
    "keywords": "Interface IMagicPageContextKit Namespace ToSic.Cre8magic.PageContexts Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface IMagicPageContextKit Properties Classes string? Classes { get; } Property Value string Spell MagicPageContextSpell Spell { get; } Property Value MagicPageContextSpell TagId string? TagId { get; } Property Value string UseBodyTag bool UseBodyTag { get; } Property Value bool Methods UpdateBodyTag() Task UpdateBodyTag() Returns Task"
  },
  "api/ToSic.Cre8magic.PageContexts.MagicPageContext.html": {
    "href": "api/ToSic.Cre8magic.PageContexts.MagicPageContext.html",
    "title": "Class MagicPageContext | cre8magic",
    "keywords": "Class MagicPageContext Namespace ToSic.Cre8magic.PageContexts Assembly ToSic.Cre8magic.Client.Oqtane.dll public class MagicPageContext : ComponentBase Inheritance object ComponentBase MagicPageContext Properties ChildContent The HTML contents which is wrapped by this component. If the settings specify that it uses the Body tag, then no div is added. Otherwise, everything will be wrapped in a div with the magic CSS classes. [Parameter] public RenderFragment? ChildContent { get; set; } Property Value RenderFragment PageState Get the PageState from the CascadingParameter [CascadingParameter] public required PageState PageState { get; set; } Property Value PageState Settings [Parameter] public MagicPageContextSpell? Settings { get; set; } Property Value MagicPageContextSpell Methods OnAfterRenderAsync(bool) Method invoked after each time the component has been rendered interactively and the UI has finished updating (for example, after elements have been added to the browser DOM). Any Microsoft.AspNetCore.Components.ElementReference fields will be populated by the time this runs. This method is not invoked during prerendering or server-side rendering, because those processes are not attached to any live browser DOM and are already complete before the DOM is updated. Note that the component does not automatically re-render after the completion of any returned System.Threading.Tasks.Task, because that would cause an infinite render loop. protected override Task OnAfterRenderAsync(bool firstRender) Parameters firstRender bool Set to true if this is the first time Microsoft.AspNetCore.Components.ComponentBase.OnAfterRender(bool) has been invoked on this component instance; otherwise false. Returns Task A System.Threading.Tasks.Task representing any asynchronous operation. Remarks The Microsoft.AspNetCore.Components.ComponentBase.OnAfterRender(bool) and Microsoft.AspNetCore.Components.ComponentBase.OnAfterRenderAsync(bool) lifecycle methods are useful for performing interop, or interacting with values received from @ref. Use the firstRender parameter to ensure that initialization work is only performed once."
  },
  "api/ToSic.Cre8magic.PageContexts.MagicPageContextSpell.html": {
    "href": "api/ToSic.Cre8magic.PageContexts.MagicPageContextSpell.html",
    "title": "Class MagicPageContextSpell | cre8magic",
    "keywords": "Class MagicPageContextSpell Namespace ToSic.Cre8magic.PageContexts Assembly ToSic.Cre8magic.Client.Oqtane.dll Magic Page Context Settings - Data. This configures how the page context is rendered, and what classes are added to the body tag. public record MagicPageContextSpell : MagicSpellBase Inheritance object MagicInheritsBase MagicSpellBase MagicPageContextSpell Inherited Members MagicSpellBase.PageState MagicSpellBase.Name MagicSpellBase.Debug MagicInheritsBase.Inherits Extension Methods MagicSpellExtensions.Refill<TSpell>(TSpell?, PageState) MagicSpellExtensions.Refill<TSpell, TWith>(TSpell?, TWith?) MagicSpellExtensions.With<TSpell>(TSpell?, PageState, string?) MagicSpellExtensions.With<TSpell, TWith>(TSpell?, TWith?) Properties ClassList List of classes to add for the context. Should usually contain placeholders. public string[]? ClassList { get; init; } Property Value string[] Classes public string? Classes { get; init; } Property Value string PageIsHome Classes to use if the page is the home page - or not. public MagicSettingOnOff? PageIsHome { get; init; } Property Value MagicSettingOnOff TagId public string? TagId { get; init; } Property Value string UseBodyTag If true, the body tag will be used to add classes and other attributes. If false, it will use a div around the content. public bool? UseBodyTag { get; init; } Property Value bool?"
  },
  "api/ToSic.Cre8magic.PageContexts.MagicPageContextTailor.html": {
    "href": "api/ToSic.Cre8magic.PageContexts.MagicPageContextTailor.html",
    "title": "Class MagicPageContextTailor | cre8magic",
    "keywords": "Class MagicPageContextTailor Namespace ToSic.Cre8magic.PageContexts Assembly ToSic.Cre8magic.Client.Oqtane.dll Special helper to figure out what classes should be applied to the page. public class MagicPageContextTailor Inheritance object MagicPageContextTailor Constructors MagicPageContextTailor(MagicPageContextSpell, PageState) Special helper to figure out what classes should be applied to the page. public MagicPageContextTailor(MagicPageContextSpell spell, PageState pageState) Parameters spell MagicPageContextSpell pageState PageState"
  },
  "api/ToSic.Cre8magic.PageContexts.html": {
    "href": "api/ToSic.Cre8magic.PageContexts.html",
    "title": "Namespace ToSic.Cre8magic.PageContexts | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.PageContexts Classes MagicPageContext MagicPageContextSpell Magic Page Context Settings - Data. This configures how the page context is rendered, and what classes are added to the body tag. MagicPageContextTailor Special helper to figure out what classes should be applied to the page. Interfaces IMagicPageContextKit"
  },
  "api/ToSic.Cre8magic.Pages.IMagicPage.html": {
    "href": "api/ToSic.Cre8magic.Pages.IMagicPage.html",
    "title": "Interface IMagicPage | cre8magic",
    "keywords": "Interface IMagicPage Namespace ToSic.Cre8magic.Pages Assembly ToSic.Cre8magic.Client.Oqtane.dll Magic Pages are smart wrappers around Oqtane Pages. They offer many benefits such as: Read-only properties (no accidental writing properties with unexpected side effects) Improved naming, e.g. .Id instead of .PageId Calculated properties such as Target (which becomes \"_blank\" for external links or null for normal links) Corrected values - e.g. the Link property will be javascript:void(0) if the page is not clickable Navigation properties such as Parent and Breadcrumb public interface IMagicPage Properties Breadcrumb The current pages bread-crumb, going from the top-level to the current page. Note that the \"Home\" page is usually not a parent, so it's not included. IEnumerable<IMagicPage> Breadcrumb { get; } Property Value IEnumerable<IMagicPage> Children IEnumerable<IMagicPage> Children { get; } Property Value IEnumerable<IMagicPage> HasChildren Determines if there are sub-pages. Note that this information will vary by user (because of permissions) and scenario. For example, when creating a menu which should only show 1 level, all pages will declare they have no children. bool HasChildren { get; } Property Value bool Id ID of this Page int Id { get; } Property Value int IsActive True if this page is the active / current page which the user is viewing. bool IsActive { get; } Property Value bool IsClickable Link in site navigation is enabled or disabled. bool IsClickable { get; } Property Value bool IsHome True if this is the home page. bool IsHome { get; } Property Value bool IsInBreadcrumb Determine if the menu page is in the breadcrumb. bool IsInBreadcrumb { get; } Property Value bool Level Current page level from the top of the Menu. As in Oqtane, it's 0 based. int Level { get; } Property Value int Link Link to this page. string Link { get; } Property Value string MenuLevel Level in the menu, starting from 1. As different menus may start at other depths, this is not always the same as the Oqtane level. Note that when building menus or breadcrumbs, this menu-level is recalculated to fit the current menu. So if the menu itself starts at another level (e.g. showing only all pages under Products), then these pages would declare they are MenuLevel=1 int MenuLevel { get; } Property Value int Name Page Name. string Name { get; } Property Value string Parent The parent page of this page. IMagicPage? Parent { get; } Property Value IMagicPage The parent page, or null if the page is on the top level and doesn't have a parent page. ParentId Reference to the parent Oqtane.Models.Page if it has one. int? ParentId { get; } Property Value int? Path Path of the page. string Path { get; } Property Value string RawPage Original Oqtane page wrapped in MagicPage. Can be used to access additional properties of the Oqtane page. Page RawPage { get; } Property Value Page Target Target for link to this page. string? Target { get; } Property Value string Url Full URL to this page. string Url { get; } Property Value string Methods Classes(string) Get css class for something - typically a tag. string? Classes(string tagOrKey) Parameters tagOrKey string Returns string Value(string) Get some value - often for an attribute or something similar. string? Value(string tagOrKey) Parameters tagOrKey string Returns string"
  },
  "api/ToSic.Cre8magic.Pages.IMagicPageSetSettings.html": {
    "href": "api/ToSic.Cre8magic.Pages.IMagicPageSetSettings.html",
    "title": "Interface IMagicPageSetSettings | cre8magic",
    "keywords": "Interface IMagicPageSetSettings Namespace ToSic.Cre8magic.Pages Assembly ToSic.Cre8magic.Client.Oqtane.dll WIP TODO: naming not final public interface IMagicPageSetSettings Properties Id Id of the settings, usually a random number TODO: UNCLEAR difference to MenuId - or could be the same? string? Id { get; } Property Value string MenuId Menu ID for use in JavaScript etc. Usually predefined OR a random number string MenuId { get; } Property Value string Variant string? Variant { get; } Property Value string"
  },
  "api/ToSic.Cre8magic.Pages.IMagicPageTailor.html": {
    "href": "api/ToSic.Cre8magic.Pages.IMagicPageTailor.html",
    "title": "Interface IMagicPageTailor | cre8magic",
    "keywords": "Interface IMagicPageTailor Namespace ToSic.Cre8magic.Pages Assembly ToSic.Cre8magic.Client.Oqtane.dll Interface for a designer of a magic page. Anything implementing this interface can be used as a designer for a magic page, providing custom classes and values when generating the HTML for the page. public interface IMagicPageTailor Methods Classes(string, IMagicPage) string? Classes(string tag, IMagicPage page) Parameters tag string page IMagicPage Returns string Value(string, IMagicPage) string? Value(string key, IMagicPage page) Parameters key string page IMagicPage Returns string"
  },
  "api/ToSic.Cre8magic.Pages.MagicPageEditService.html": {
    "href": "api/ToSic.Cre8magic.Pages.MagicPageEditService.html",
    "title": "Class MagicPageEditService | cre8magic",
    "keywords": "Class MagicPageEditService Namespace ToSic.Cre8magic.Pages Assembly ToSic.Cre8magic.Client.Oqtane.dll Helper to remove the logic/code from the razor file. It's just meant to support the AdminButtons, without placing the logic code inside that. public class MagicPageEditService Inheritance object MagicPageEditService Constructors MagicPageEditService(IPageService, NavigationManager) Helper to remove the logic/code from the razor file. It's just meant to support the AdminButtons, without placing the logic code inside that. public MagicPageEditService(IPageService pageService, NavigationManager navigationManager) Parameters pageService IPageService navigationManager NavigationManager Methods ToggleEditMode(PageState) public Task ToggleEditMode(PageState pageState) Parameters pageState PageState Returns Task"
  },
  "api/ToSic.Cre8magic.Pages.MagicPageTailorBase.html": {
    "href": "api/ToSic.Cre8magic.Pages.MagicPageTailorBase.html",
    "title": "Class MagicPageTailorBase | cre8magic",
    "keywords": "Class MagicPageTailorBase Namespace ToSic.Cre8magic.Pages Assembly ToSic.Cre8magic.Client.Oqtane.dll Base class for page designers. Can be used as a foundation for creating your custom designers. This is a bit safer than just implementing the interface, as future enhancements would appear on this class so your implementation would work even on an upgrade. public class MagicPageTailorBase : IMagicPageTailor Inheritance object MagicPageTailorBase Implements IMagicPageTailor Derived MagicPageTailorBasic Methods Classes(string, IMagicPage) Very basic implementation of the Classes generator. Will return null if not overriden. public virtual string? Classes(string tag, IMagicPage item) Parameters tag string item IMagicPage Returns string Value(string, IMagicPage) Very basic implementation of the Value generator. Will return null if not overriden. public virtual string? Value(string key, IMagicPage item) Parameters key string item IMagicPage Returns string"
  },
  "api/ToSic.Cre8magic.Pages.MagicPageTailorBasic.html": {
    "href": "api/ToSic.Cre8magic.Pages.MagicPageTailorBasic.html",
    "title": "Class MagicPageTailorBasic | cre8magic",
    "keywords": "Class MagicPageTailorBasic Namespace ToSic.Cre8magic.Pages Assembly ToSic.Cre8magic.Client.Oqtane.dll Simple page designer for breadcrumbs or menus. If no lookups are specified, the Classes(...) and Data(...) methods will return empty strings. public class MagicPageTailorBasic : MagicPageTailorBase, IMagicPageTailor Inheritance object MagicPageTailorBase MagicPageTailorBasic Implements IMagicPageTailor Derived MagicBreadcrumbTailorBs5 Remarks This is also a great candidate to inherit from, as you can specify the Lookups in the constructor. The methods are also virtual, so you can override them as needed. Fields All public static string All Field Value string Properties LookupClassActive The class to add to the active item. Note that it will be applied to all tags. For more advanced scenarios, you may want to override the Classes method. public string? LookupClassActive { get; init; } Property Value string LookupClasses Dictionary which is used to lookup what classes to provide for each tag. Can be specified when creating an instance of this class. We recommend to supply a case-insensitive dictionary. public IDictionary<string, string> LookupClasses { get; init; } Property Value IDictionary<string, string> LookupData Dictionary which is used to lookup what data/values to provide for each tag. Can be specified when creating an instance of this class. We recommend to supply a case-insensitive dictionary. public IDictionary<string, string> LookupData { get; init; } Property Value IDictionary<string, string> Methods Classes(string, IMagicPage) Very basic implementation of the Classes generator. Will combine classes from the ClassLookup and ClassActive properties. public override string? Classes(string tag, IMagicPage item) Parameters tag string item IMagicPage Returns string a space-separated list of classes, or null Value(string, IMagicPage) Very basic implementation of the Data/Value generator. Will use the LookupData to find the value for the key. public override string? Value(string key, IMagicPage item) Parameters key string item IMagicPage Returns string"
  },
  "api/ToSic.Cre8magic.Pages.html": {
    "href": "api/ToSic.Cre8magic.Pages.html",
    "title": "Namespace ToSic.Cre8magic.Pages | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Pages Classes MagicPageEditService Helper to remove the logic/code from the razor file. It's just meant to support the AdminButtons, without placing the logic code inside that. MagicPageTailorBase Base class for page designers. Can be used as a foundation for creating your custom designers. This is a bit safer than just implementing the interface, as future enhancements would appear on this class so your implementation would work even on an upgrade. MagicPageTailorBasic Simple page designer for breadcrumbs or menus. If no lookups are specified, the Classes(...) and Data(...) methods will return empty strings. Interfaces IMagicPage Magic Pages are smart wrappers around Oqtane Pages. They offer many benefits such as: Read-only properties (no accidental writing properties with unexpected side effects) Improved naming, e.g. .Id instead of .PageId Calculated properties such as Target (which becomes \"_blank\" for external links or null for normal links) Corrected values - e.g. the Link property will be javascript:void(0) if the page is not clickable Navigation properties such as Parent and Breadcrumb IMagicPageSetSettings WIP TODO: naming not final IMagicPageTailor Interface for a designer of a magic page. Anything implementing this interface can be used as a designer for a magic page, providing custom classes and values when generating the HTML for the page."
  },
  "api/ToSic.Cre8magic.Spells.Debug.MagicDebugSettings.html": {
    "href": "api/ToSic.Cre8magic.Spells.Debug.MagicDebugSettings.html",
    "title": "Class MagicDebugSettings | cre8magic",
    "keywords": "Class MagicDebugSettings Namespace ToSic.Cre8magic.Spells.Debug Assembly ToSic.Cre8magic.Client.Oqtane.dll Debug settings to help during development. These settings can also be loaded from the configuration. This allows you to do things like enable temporarily for admins, without restarting/recompiling anything. public record MagicDebugSettings Inheritance object MagicDebugSettings Constructors MagicDebugSettings(bool) Create debug settings which set everything to the specified state. This is mainly for quick interventions, so you can just do new(true) to enable everything. public MagicDebugSettings(bool enable) Parameters enable bool Properties Admin public bool? Admin { get; init; } Property Value bool? Allowed public bool? Allowed { get; init; } Property Value bool? Anonymous public bool? Anonymous { get; init; } Property Value bool? Detailed public bool? Detailed { get; init; } Property Value bool?"
  },
  "api/ToSic.Cre8magic.Spells.Debug.html": {
    "href": "api/ToSic.Cre8magic.Spells.Debug.html",
    "title": "Namespace ToSic.Cre8magic.Spells.Debug | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Spells.Debug Classes MagicDebugSettings Debug settings to help during development. These settings can also be loaded from the configuration. This allows you to do things like enable temporarily for admins, without restarting/recompiling anything."
  },
  "api/ToSic.Cre8magic.Spells.IMagicSpellsProvider.html": {
    "href": "api/ToSic.Cre8magic.Spells.IMagicSpellsProvider.html",
    "title": "Interface IMagicSpellsProvider | cre8magic",
    "keywords": "Interface IMagicSpellsProvider Namespace ToSic.Cre8magic.Spells Assembly ToSic.Cre8magic.Client.Oqtane.dll Provider to give settings. It is scoped, so anything added to it - typically in the Theme, will be available in all other components. public interface IMagicSpellsProvider Properties Analytics IMagicSpellsProviderSection<MagicAnalyticsSpell> Analytics { get; } Property Value IMagicSpellsProviderSection<MagicAnalyticsSpell> Breadcrumbs IMagicSpellsProviderSection<MagicBreadcrumbSpell> Breadcrumbs { get; } Property Value IMagicSpellsProviderSection<MagicBreadcrumbSpell> Containers IMagicSpellsProviderSection<MagicContainerSpell> Containers { get; } Property Value IMagicSpellsProviderSection<MagicContainerSpell> MenuBlueprints IMagicSpellsProviderSection<MagicMenuBlueprint> MenuBlueprints { get; } Property Value IMagicSpellsProviderSection<MagicMenuBlueprint> Themes IMagicSpellsProviderSection<MagicThemeSpell> Themes { get; } Property Value IMagicSpellsProviderSection<MagicThemeSpell> Methods Provide(MagicSpellsBook) IMagicSpellsProvider Provide(MagicSpellsBook book) Parameters book MagicSpellsBook Returns IMagicSpellsProvider Reset() void Reset()"
  },
  "api/ToSic.Cre8magic.Spells.IMagicSpellsProviderSection-1.html": {
    "href": "api/ToSic.Cre8magic.Spells.IMagicSpellsProviderSection-1.html",
    "title": "Interface IMagicSpellsProviderSection<TSettings> | cre8magic",
    "keywords": "Interface IMagicSpellsProviderSection<TSettings> Namespace ToSic.Cre8magic.Spells Assembly ToSic.Cre8magic.Client.Oqtane.dll A provider for one type of settings. public interface IMagicSpellsProviderSection<TSettings> where TSettings : class Type Parameters TSettings Methods Provide(IDictionary<string, TSettings>) Configure to provide a dictionary of named values. IMagicSpellsProvider Provide(IDictionary<string, TSettings> dictionary) Parameters dictionary IDictionary<string, TSettings> Returns IMagicSpellsProvider Provide(string, TSettings) Configure to provide a named value. IMagicSpellsProvider Provide(string key, TSettings value) Parameters key string value TSettings Returns IMagicSpellsProvider SetDefault(TSettings) Configure to provide a value - either as the only result for all requests, or as a default. IMagicSpellsProvider SetDefault(TSettings value) Parameters value TSettings Returns IMagicSpellsProvider"
  },
  "api/ToSic.Cre8magic.Spells.MagicInheritsBase.html": {
    "href": "api/ToSic.Cre8magic.Spells.MagicInheritsBase.html",
    "title": "Class MagicInheritsBase | cre8magic",
    "keywords": "Class MagicInheritsBase Namespace ToSic.Cre8magic.Spells Assembly ToSic.Cre8magic.Client.Oqtane.dll public abstract record MagicInheritsBase Inheritance object MagicInheritsBase Derived MagicSpellBase MagicBlueprint Remarks Created as a base record, not as an interface, because for processing we need to ensure it's always a record Properties Inherits Name of configuration it inherits. [JsonPropertyName(\"@inherits\")] public string? Inherits { get; init; } Property Value string"
  },
  "api/ToSic.Cre8magic.Spells.MagicSpellBase.html": {
    "href": "api/ToSic.Cre8magic.Spells.MagicSpellBase.html",
    "title": "Class MagicSpellBase | cre8magic",
    "keywords": "Class MagicSpellBase Namespace ToSic.Cre8magic.Spells Assembly ToSic.Cre8magic.Client.Oqtane.dll Internal base class containing all kinds of settings which all spells share. public abstract record MagicSpellBase : MagicInheritsBase Inheritance object MagicInheritsBase MagicSpellBase Derived MagicAnalyticsSpell MagicBreadcrumbSpell MagicContainerSpell MagicLanguageSpell MagicLinkSettings MagicMenuSpell MagicPageContextSpell MagicThemeSpell MagicUserLoginSpell MagicUserSpell Inherited Members MagicInheritsBase.Inherits Properties Debug Debug settings for anything that can configure show/hide of debug public MagicDebugSettings? Debug { get; init; } Property Value MagicDebugSettings Name Name to identify this part. This information is used to load settings (menu settings and design settings) [JsonIgnore] public string? Name { get; init; } Property Value string PageState The PageState which is needed for doing everything. It can be provided in the settings, or it must be provided in the theme using UsePageState(PageState). [JsonIgnore] public PageState? PageState { get; init; } Property Value PageState"
  },
  "api/ToSic.Cre8magic.Spells.MagicSpellExtensions.html": {
    "href": "api/ToSic.Cre8magic.Spells.MagicSpellExtensions.html",
    "title": "Class MagicSpellExtensions | cre8magic",
    "keywords": "Class MagicSpellExtensions Namespace ToSic.Cre8magic.Spells Assembly ToSic.Cre8magic.Client.Oqtane.dll Extensions for working with MagicSettings, to make the API more fluent and easier to use. public static class MagicSpellExtensions Inheritance object MagicSpellExtensions Remarks Despite it being related to Settings (which would normally be in ToSic.Cre8magic.Spells), it's in the Act namespace because it's usually used in the basic work which starts in this namespace. This makes it easier for most components to just use this namespace and little else. Methods Refill<TSpell>(TSpell?, PageState) Fill in the PageState if not yet set. This is to set the value if it's missing, but preserve any existing one. Alternative is With<TSpell>(TSpell?, PageState, string?) public static TSpell Refill<TSpell>(this TSpell? settings, PageState pageState) where TSpell : MagicSpellBase, new() Parameters settings TSpell The initial settings object - can be null (in which case a fresh one is created) pageState PageState The PageState to back-fill Returns TSpell Type Parameters TSpell The settings-type we're updating. Refill<TSpell, TWith>(TSpell?, TWith?) public static TSpell Refill<TSpell, TWith>(this TSpell? settings, TWith? addition) where TSpell : MagicSpellBase, IWith<TWith?>, new() where TWith : class Parameters settings TSpell addition TWith Returns TSpell Type Parameters TSpell TWith With<TSpell>(TSpell?, PageState, string?) Add a PageState to a settings object. This uses normal record with manipulations, so it creates a new object but preserves all other settings. Alternative when only filling empty Refill<TSpell>(TSpell?, PageState) public static TSpell With<TSpell>(this TSpell? settings, PageState pageState, string? name = null) where TSpell : MagicSpellBase, new() Parameters settings TSpell The initial settings object - can be null (in which case a fresh one is created) pageState PageState The PageState name string The name of default settings to load Returns TSpell Type Parameters TSpell The settings-type we're updating. With<TSpell, TWith>(TSpell?, TWith?) public static TSpell With<TSpell, TWith>(this TSpell? settings, TWith? addition) where TSpell : MagicSpellBase, IWith<TWith?>, new() where TWith : class Parameters settings TSpell addition TWith Returns TSpell Type Parameters TSpell TWith"
  },
  "api/ToSic.Cre8magic.Spells.MagicSpellLookup.html": {
    "href": "api/ToSic.Cre8magic.Spells.MagicSpellLookup.html",
    "title": "Class MagicSpellLookup | cre8magic",
    "keywords": "Class MagicSpellLookup Namespace ToSic.Cre8magic.Spells Assembly ToSic.Cre8magic.Client.Oqtane.dll public record MagicSpellLookup Inheritance object MagicSpellLookup Properties BlueprintName public string? BlueprintName { get; init; } Property Value string PartName public string? PartName { get; init; } Property Value string SpellName public string? SpellName { get; init; } Property Value string"
  },
  "api/ToSic.Cre8magic.Spells.MagicSpellsBook.html": {
    "href": "api/ToSic.Cre8magic.Spells.MagicSpellsBook.html",
    "title": "Class MagicSpellsBook | cre8magic",
    "keywords": "Class MagicSpellsBook Namespace ToSic.Cre8magic.Spells Assembly ToSic.Cre8magic.Client.Oqtane.dll This is a Spells Book; a catalog of all kinds of settings. It serves as a kind of database to manage all settings, which will usually be retrieved using a name. public record MagicSpellsBook Inheritance object MagicSpellsBook Constructors MagicSpellsBook() Empty Constructor so it can be created in code and Json-Deserialized public MagicSpellsBook() Fields SourceDefault public const string SourceDefault = \"Unknown\" Field Value string Properties Analytics [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicAnalyticsSpell>))] public Dictionary<string, MagicAnalyticsSpell> Analytics { get; init; } Property Value Dictionary<string, MagicAnalyticsSpell> BreadcrumbBlueprints [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicBreadcrumbBlueprint>))] public Dictionary<string, MagicBreadcrumbBlueprint> BreadcrumbBlueprints { get; init; } Property Value Dictionary<string, MagicBreadcrumbBlueprint> Breadcrumbs [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicBreadcrumbSpell>))] public Dictionary<string, MagicBreadcrumbSpell> Breadcrumbs { get; init; } Property Value Dictionary<string, MagicBreadcrumbSpell> ContainerBlueprints [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicContainerBlueprint>))] public Dictionary<string, MagicContainerBlueprint> ContainerBlueprints { get; init; } Property Value Dictionary<string, MagicContainerBlueprint> Containers [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicContainerSpell>))] public Dictionary<string, MagicContainerSpell> Containers { get; init; } Property Value Dictionary<string, MagicContainerSpell> Debug Master debug settings - would override other debugs public MagicDebugSettings? Debug { get; init; } Property Value MagicDebugSettings LanguageBlueprints Design definitions of languages [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicLanguageBlueprint>))] public Dictionary<string, MagicLanguageBlueprint> LanguageBlueprints { get; init; } Property Value Dictionary<string, MagicLanguageBlueprint> Languages Language Settings [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicLanguageSpell>))] public Dictionary<string, MagicLanguageSpell> Languages { get; init; } Property Value Dictionary<string, MagicLanguageSpell> MenuBlueprints Design definitions of the menu [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicMenuBlueprint>))] public Dictionary<string, MagicMenuBlueprint> MenuBlueprints { get; init; } Property Value Dictionary<string, MagicMenuBlueprint> Menus The menu definitions [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicMenuSpell>))] public Dictionary<string, MagicMenuSpell> Menus { get; init; } Property Value Dictionary<string, MagicMenuSpell> PageContexts The menu definitions [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicPageContextSpell>))] public Dictionary<string, MagicPageContextSpell> PageContexts { get; init; } Property Value Dictionary<string, MagicPageContextSpell> Source Source of these settings / where they came from, to ensure that we can see in debug where a value was picked up from public string Source { get; set; } Property Value string ThemeBlueprints [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicThemeBlueprint>))] public Dictionary<string, MagicThemeBlueprint> ThemeBlueprints { get; init; } Property Value Dictionary<string, MagicThemeBlueprint> Themes List of Themes and mainly what parts they want to explicitly configure (e.g. determine Show, and there these parts find their settings) [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicThemeSpell>))] public Dictionary<string, MagicThemeSpell> Themes { get; init; } Property Value Dictionary<string, MagicThemeSpell> Version Version number when loading from JSON to verify it's what we expect public float Version { get; init; } Property Value float"
  },
  "api/ToSic.Cre8magic.Spells.Settings.MagicSettingOnOff.html": {
    "href": "api/ToSic.Cre8magic.Spells.Settings.MagicSettingOnOff.html",
    "title": "Class MagicSettingOnOff | cre8magic",
    "keywords": "Class MagicSettingOnOff Namespace ToSic.Cre8magic.Spells.Settings Assembly ToSic.Cre8magic.Client.Oqtane.dll Special Setting containing a value to be used when a state is on or off. Typically used to specify strings to place in classes when something: is active is home etc. [JsonConverter(typeof(SettingOnOffJsonConverter))] public record MagicSettingOnOff Inheritance object MagicSettingOnOff Constructors MagicSettingOnOff(string?, string?) public MagicSettingOnOff(string? on, string? off = null) Parameters on string off string Properties Off Value / Class to add if the setting is off public string? Off { get; init; } Property Value string On Value / Class to add if the setting is on public string? On { get; init; } Property Value string"
  },
  "api/ToSic.Cre8magic.Spells.Settings.html": {
    "href": "api/ToSic.Cre8magic.Spells.Settings.html",
    "title": "Namespace ToSic.Cre8magic.Spells.Settings | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Spells.Settings Classes MagicSettingOnOff Special Setting containing a value to be used when a state is on or off. Typically used to specify strings to place in classes when something: is active is home etc."
  },
  "api/ToSic.Cre8magic.Spells.html": {
    "href": "api/ToSic.Cre8magic.Spells.html",
    "title": "Namespace ToSic.Cre8magic.Spells | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Spells Namespaces ToSic.Cre8magic.Spells.Debug ToSic.Cre8magic.Spells.Settings Classes MagicInheritsBase MagicSpellBase Internal base class containing all kinds of settings which all spells share. MagicSpellExtensions Extensions for working with MagicSettings, to make the API more fluent and easier to use. MagicSpellsBook This is a Spells Book; a catalog of all kinds of settings. It serves as a kind of database to manage all settings, which will usually be retrieved using a name. Interfaces IMagicSpellsProvider Provider to give settings. It is scoped, so anything added to it - typically in the Theme, will be available in all other components. IMagicSpellsProviderSection<TSettings> A provider for one type of settings."
  },
  "api/ToSic.Cre8magic.Tailors.IMagicTailor.html": {
    "href": "api/ToSic.Cre8magic.Tailors.IMagicTailor.html",
    "title": "Interface IMagicTailor | cre8magic",
    "keywords": "Interface IMagicTailor Namespace ToSic.Cre8magic.Tailors Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface IMagicTailor Methods Classes(string) string? Classes(string target) Parameters target string Returns string Id(string) string? Id(string target) Parameters target string Returns string Value(string) string? Value(string target) Parameters target string Returns string"
  },
  "api/ToSic.Cre8magic.Tailors.MagicBlueprint.html": {
    "href": "api/ToSic.Cre8magic.Tailors.MagicBlueprint.html",
    "title": "Class MagicBlueprint | cre8magic",
    "keywords": "Class MagicBlueprint Namespace ToSic.Cre8magic.Tailors Assembly ToSic.Cre8magic.Client.Oqtane.dll Menu Design Settings public record MagicBlueprint : MagicInheritsBase Inheritance object MagicInheritsBase MagicBlueprint Derived MagicBreadcrumbBlueprint MagicContainerBlueprint MagicLanguageBlueprint MagicMenuBlueprint MagicThemeBlueprint Inherited Members MagicInheritsBase.Inherits Properties Parts Custom, named settings for classes, values etc. as you need them in your code. For things such as ul or li or a tags. [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicBlueprintPart>))] public Dictionary<string, MagicBlueprintPart> Parts { get; init; } Property Value Dictionary<string, MagicBlueprintPart>"
  },
  "api/ToSic.Cre8magic.Tailors.MagicBlueprintPart.html": {
    "href": "api/ToSic.Cre8magic.Tailors.MagicBlueprintPart.html",
    "title": "Class MagicBlueprintPart | cre8magic",
    "keywords": "Class MagicBlueprintPart Namespace ToSic.Cre8magic.Tailors Assembly ToSic.Cre8magic.Client.Oqtane.dll Anything that can define what classes it should have. This is usually the base class for something that can also have more information. [JsonConverter(typeof(BlueprintPartJsonConverter))] public record MagicBlueprintPart Inheritance object MagicBlueprintPart Properties ByLevel List of classes to add on certain levels only. Use level -1 to specify classes to apply to all the remaining ones which are not explicitly listed. public Dictionary<int, string>? ByLevel { get; init; } Property Value Dictionary<int, string> Classes Classes which are applied to all the tags of this type public string? Classes { get; init; } Property Value string HasChildren Classes to add if this node is a parent (has-children). public MagicSettingOnOff? HasChildren { get; init; } Property Value MagicSettingOnOff Id public string? Id { get; init; } Property Value string InBreadcrumb Classes to add if this node is in the path / breadcrumb of the current page. public MagicSettingOnOff? InBreadcrumb { get; init; } Property Value MagicSettingOnOff IsActive Classes to apply if this thing is active. For example, the current page or language. public MagicSettingOnOff? IsActive { get; init; } Property Value MagicSettingOnOff IsAdmin If a module is admin or not, usually just for containers public MagicSettingOnOff? IsAdmin { get; init; } Property Value MagicSettingOnOff IsDisabled Classes to add if the node is disabled. TODO: unclear why it's disabled, what would cause this... public MagicSettingOnOff? IsDisabled { get; init; } Property Value MagicSettingOnOff IsPublished If something is published or not, usually just for Containers public MagicSettingOnOff? IsPublished { get; init; } Property Value MagicSettingOnOff Value Special key to get a value - for non-css settings public string? Value { get; init; } Property Value string"
  },
  "api/ToSic.Cre8magic.Tailors.MagicTailorBase.html": {
    "href": "api/ToSic.Cre8magic.Tailors.MagicTailorBase.html",
    "title": "Class MagicTailorBase | cre8magic",
    "keywords": "Class MagicTailorBase Namespace ToSic.Cre8magic.Tailors Assembly ToSic.Cre8magic.Client.Oqtane.dll public abstract class MagicTailorBase : IMagicTailor Inheritance object MagicTailorBase Implements IMagicTailor Derived MagicContainerTailor MagicLanguageTailor Constructors MagicTailorBase(TokenEngine, Dictionary<string, MagicBlueprintPart>) protected MagicTailorBase(TokenEngine tokens, Dictionary<string, MagicBlueprintPart> parts) Parameters tokens TokenEngine parts Dictionary<string, MagicBlueprintPart> Properties ParseTokens protected virtual bool ParseTokens { get; } Property Value bool Parts protected Dictionary<string, MagicBlueprintPart> Parts { get; } Property Value Dictionary<string, MagicBlueprintPart> Methods Classes(string) public virtual string? Classes(string target) Parameters target string Returns string GetSettings(string) protected MagicBlueprintPart? GetSettings(string name) Parameters name string Returns MagicBlueprintPart Id(string) public string? Id(string name) Parameters name string Returns string ProcessTokens(string?) protected string? ProcessTokens(string? value) Parameters value string Returns string Value(string) public string? Value(string target) Parameters target string Returns string"
  },
  "api/ToSic.Cre8magic.Tailors.html": {
    "href": "api/ToSic.Cre8magic.Tailors.html",
    "title": "Namespace ToSic.Cre8magic.Tailors | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Tailors Classes MagicBlueprint Menu Design Settings MagicBlueprintPart Anything that can define what classes it should have. This is usually the base class for something that can also have more information. MagicTailorBase Interfaces IMagicTailor"
  },
  "api/ToSic.Cre8magic.Themes.IMagicThemeJsService.html": {
    "href": "api/ToSic.Cre8magic.Themes.IMagicThemeJsService.html",
    "title": "Interface IMagicThemeJsService | cre8magic",
    "keywords": "Interface IMagicThemeJsService Namespace ToSic.Cre8magic.Themes Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface IMagicThemeJsService Methods Log(params object[]) Task Log(params object[] args) Parameters args object[] Returns Task SetBodyClasses(string) Set body classes (removes all previous classes in the process) Task SetBodyClasses(string classes) Parameters classes string Returns Task"
  },
  "api/ToSic.Cre8magic.Themes.IMagicThemeKit.html": {
    "href": "api/ToSic.Cre8magic.Themes.IMagicThemeKit.html",
    "title": "Interface IMagicThemeKit | cre8magic",
    "keywords": "Interface IMagicThemeKit Namespace ToSic.Cre8magic.Themes Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface IMagicThemeKit Properties Logo string Logo { get; } Property Value string Spell MagicThemeSpell Spell { get; } Property Value MagicThemeSpell Tailor MagicThemeTailor Tailor { get; } Property Value MagicThemeTailor Methods ShowPart(string) Determine if we should show a specific part bool ShowPart(string name) Parameters name string Returns bool"
  },
  "api/ToSic.Cre8magic.Themes.IMagicThemeService.html": {
    "href": "api/ToSic.Cre8magic.Themes.IMagicThemeService.html",
    "title": "Interface IMagicThemeService | cre8magic",
    "keywords": "Interface IMagicThemeService Namespace ToSic.Cre8magic.Themes Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface IMagicThemeService Methods ThemeKit(PageState, MagicThemeSpell?) Get a theme kit for the current page, to customize the theme. IMagicThemeKit ThemeKit(PageState pageState, MagicThemeSpell? settings) Parameters pageState PageState The Page State settings MagicThemeSpell The Settings; optional Returns IMagicThemeKit"
  },
  "api/ToSic.Cre8magic.Themes.MagicThemeBase.html": {
    "href": "api/ToSic.Cre8magic.Themes.MagicThemeBase.html",
    "title": "Class MagicThemeBase | cre8magic",
    "keywords": "Class MagicThemeBase Namespace ToSic.Cre8magic.Themes Assembly ToSic.Cre8magic.Client.Oqtane.dll Base class for our themes. It's responsible for Some basic properties such as Name, BodyClasses etc. which each theme can configure Adding special classes to the body tag so that the CSS can best optimize for each scenario public abstract class MagicThemeBase : ThemeBase Inheritance object ComponentBase ThemeBase MagicThemeBase Remarks The base class must be abstract, so that Oqtane doesn't see it as a real them. The config-properties must be abstract, so the inheriting files are forced to set them. Properties MagicAct Get the MagicAct from the DI [Inject] public required IMagicAct MagicAct { get; set; } Property Value IMagicAct Name Name to show in the Theme-picker. Must be set by each inheriting theme, which is why it's marked abstract to enforce this. public override abstract string Name { get; } Property Value string ThemeKit public IMagicThemeKit ThemeKit { get; } Property Value IMagicThemeKit ThemePackage This contains the default settings which must be used in this theme. Any inheriting class must specify what it will be. public abstract MagicThemePackage ThemePackage { get; } Property Value MagicThemePackage Methods OnAfterRenderAsync(bool) OnAfterRender, track page views protected override Task OnAfterRenderAsync(bool firstRender) Parameters firstRender bool Returns Task OnInitialized() OnInitialized will run early (and once only). It also runs before OnInitializedAsync. protected override void OnInitialized() OnParametersSet() This will run whenever any parameter changes - such as PageState. It also runs before OnParametersSetAsync. protected override void OnParametersSet()"
  },
  "api/ToSic.Cre8magic.Themes.MagicThemePackage.html": {
    "href": "api/ToSic.Cre8magic.Themes.MagicThemePackage.html",
    "title": "Class MagicThemePackage | cre8magic",
    "keywords": "Class MagicThemePackage Namespace ToSic.Cre8magic.Themes Assembly ToSic.Cre8magic.Client.Oqtane.dll Settings for a Theme Package. It contains things like location of assets settings for various parts like CSS public record MagicThemePackage Inheritance object MagicThemePackage Constructors MagicThemePackage() Default / empty constructor; set properties manually. public MagicThemePackage() MagicThemePackage(ITheme, string?) Constructor to create a new theme package definition from an existing theme. public MagicThemePackage(ITheme themeInfo, string? name = null) Parameters themeInfo ITheme name string Properties Defaults All kinds of settings for the layout, how it should be etc. Should usually only serve as backup in case the JSON fails. public MagicSpellsBook? Defaults { get; init; } Property Value MagicSpellsBook Name public string? Name { get; init; } Property Value string PackageName The PackageName which is used for paths etc. public string PackageName { get; init; } Property Value string SettingsJsonFile Name of the settings file in the theme folder. Usually theme.json (default) public string SettingsJsonFile { get; init; } Property Value string ThemePath public string ThemePath { get; } Property Value string Url public string Url { get; init; } Property Value string WwwRoot Root of the WWW files - usually wwwroot (default) public string WwwRoot { get; init; } Property Value string"
  },
  "api/ToSic.Cre8magic.Themes.MagicThemeSpell.html": {
    "href": "api/ToSic.Cre8magic.Themes.MagicThemeSpell.html",
    "title": "Class MagicThemeSpell | cre8magic",
    "keywords": "Class MagicThemeSpell Namespace ToSic.Cre8magic.Themes Assembly ToSic.Cre8magic.Client.Oqtane.dll public record MagicThemeSpell : MagicSpellBase Inheritance object MagicInheritsBase MagicSpellBase MagicThemeSpell Inherited Members MagicSpellBase.PageState MagicSpellBase.Name MagicSpellBase.Debug MagicInheritsBase.Inherits Extension Methods MagicSpellExtensions.Refill<TSpell>(TSpell?, PageState) MagicSpellExtensions.Refill<TSpell, TWith>(TSpell?, TWith?) MagicSpellExtensions.With<TSpell>(TSpell?, PageState, string?) MagicSpellExtensions.With<TSpell, TWith>(TSpell?, TWith?) Properties Logo The logo to show, should be located in the assets subfolder public string? Logo { get; init; } Property Value string Parts The parts of this theme, like breadcrumb and various menu configs [JsonConverter(typeof(CaseInsensitiveDictionaryConverter<MagicThemePartSettings>))] public Dictionary<string, MagicThemePartSettings> Parts { get; init; } Property Value Dictionary<string, MagicThemePartSettings>"
  },
  "api/ToSic.Cre8magic.Themes.Settings.MagicThemeBlueprint.html": {
    "href": "api/ToSic.Cre8magic.Themes.Settings.MagicThemeBlueprint.html",
    "title": "Class MagicThemeBlueprint | cre8magic",
    "keywords": "Class MagicThemeBlueprint Namespace ToSic.Cre8magic.Themes.Settings Assembly ToSic.Cre8magic.Client.Oqtane.dll Constants and helpers related to creating Css and Css Classes. If you change these, you must also update the SCSS files. public record MagicThemeBlueprint : MagicBlueprint Inheritance object MagicInheritsBase MagicBlueprint MagicThemeBlueprint Inherited Members MagicBlueprint.Parts MagicInheritsBase.Inherits Properties PaneIsEmpty public MagicSettingOnOff? PaneIsEmpty { get; init; } Property Value MagicSettingOnOff"
  },
  "api/ToSic.Cre8magic.Themes.Settings.MagicThemePartSettings.html": {
    "href": "api/ToSic.Cre8magic.Themes.Settings.MagicThemePartSettings.html",
    "title": "Class MagicThemePartSettings | cre8magic",
    "keywords": "Class MagicThemePartSettings Namespace ToSic.Cre8magic.Themes.Settings Assembly ToSic.Cre8magic.Client.Oqtane.dll [JsonConverter(typeof(ThemePartJsonConverter))] public record MagicThemePartSettings Inheritance object MagicThemePartSettings Constructors MagicThemePartSettings(bool) public MagicThemePartSettings(bool show) Parameters show bool MagicThemePartSettings(string) public MagicThemePartSettings(string name) Parameters name string Properties Design Name of the design settings to look up. public string? Design { get; init; } Property Value string Settings Name of the settings to look up. public string? Settings { get; init; } Property Value string Show Determines if this part should be shown or not. This allows you to configure to show / not show certain bits like breadcrumbs in certain scenarios. public bool? Show { get; init; } Property Value bool?"
  },
  "api/ToSic.Cre8magic.Themes.Settings.html": {
    "href": "api/ToSic.Cre8magic.Themes.Settings.html",
    "title": "Namespace ToSic.Cre8magic.Themes.Settings | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Themes.Settings Classes MagicThemeBlueprint Constants and helpers related to creating Css and Css Classes. If you change these, you must also update the SCSS files. MagicThemePartSettings"
  },
  "api/ToSic.Cre8magic.Themes.html": {
    "href": "api/ToSic.Cre8magic.Themes.html",
    "title": "Namespace ToSic.Cre8magic.Themes | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Themes Namespaces ToSic.Cre8magic.Themes.Settings Classes MagicThemeBase Base class for our themes. It's responsible for Some basic properties such as Name, BodyClasses etc. which each theme can configure Adding special classes to the body tag so that the CSS can best optimize for each scenario MagicThemePackage Settings for a Theme Package. It contains things like location of assets settings for various parts like CSS MagicThemeSpell Interfaces IMagicThemeJsService IMagicThemeKit IMagicThemeService"
  },
  "api/ToSic.Cre8magic.Tokens.ITokenReplace.html": {
    "href": "api/ToSic.Cre8magic.Tokens.ITokenReplace.html",
    "title": "Interface ITokenReplace | cre8magic",
    "keywords": "Interface ITokenReplace Namespace ToSic.Cre8magic.Tokens Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface ITokenReplace Properties NameId string NameId { get; } Property Value string Methods Parse(string?) string? Parse(string? value) Parameters value string Returns string"
  },
  "api/ToSic.Cre8magic.Tokens.TokenEngine.html": {
    "href": "api/ToSic.Cre8magic.Tokens.TokenEngine.html",
    "title": "Class TokenEngine | cre8magic",
    "keywords": "Class TokenEngine Namespace ToSic.Cre8magic.Tokens Assembly ToSic.Cre8magic.Client.Oqtane.dll Basic token engine which takes a list of token replacers and runs them. In the future, should be a bit more modern using a token parser and token providers similar to 2sxc. But ATM there are only ca. 10 tokens so the current model is probably sufficient public class TokenEngine : ITokenReplace Inheritance object TokenEngine Implements ITokenReplace Constructors TokenEngine() public TokenEngine() TokenEngine(List<ITokenReplace>) public TokenEngine(List<ITokenReplace> parsers) Parameters parsers List<ITokenReplace> Fields NameIdConst public const string NameIdConst = \"TokenEngine\" Field Value string Properties NameId public string NameId { get; } Property Value string Parsers public ReadOnlyCollection<ITokenReplace> Parsers { get; } Property Value ReadOnlyCollection<ITokenReplace> Methods CloneWith(IMagicPage) public TokenEngine CloneWith(IMagicPage page) Parameters page IMagicPage Returns TokenEngine Expanded(ITokenReplace) public TokenEngine Expanded(ITokenReplace add) Parameters add ITokenReplace Returns TokenEngine Parse(string?) public string? Parse(string? value) Parameters value string Returns string"
  },
  "api/ToSic.Cre8magic.Tokens.html": {
    "href": "api/ToSic.Cre8magic.Tokens.html",
    "title": "Namespace ToSic.Cre8magic.Tokens | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Tokens Classes TokenEngine Basic token engine which takes a list of token replacers and runs them. In the future, should be a bit more modern using a token parser and token providers similar to 2sxc. But ATM there are only ca. 10 tokens so the current model is probably sufficient Interfaces ITokenReplace"
  },
  "api/ToSic.Cre8magic.UserLogins.IMagicUserLoginKit.html": {
    "href": "api/ToSic.Cre8magic.UserLogins.IMagicUserLoginKit.html",
    "title": "Interface IMagicUserLoginKit | cre8magic",
    "keywords": "Interface IMagicUserLoginKit Namespace ToSic.Cre8magic.UserLogins Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface IMagicUserLoginKit Properties Resources MagicUserLoginResources Resources { get; init; } Property Value MagicUserLoginResources Tailor TODO: not final, probably not correct! MagicThemeTailor Tailor { get; init; } Property Value MagicThemeTailor User MagicUser User { get; init; } Property Value MagicUser Methods ToggleLogin() Task ToggleLogin() Returns Task"
  },
  "api/ToSic.Cre8magic.UserLogins.MagicUserLoginResources.html": {
    "href": "api/ToSic.Cre8magic.UserLogins.MagicUserLoginResources.html",
    "title": "Class MagicUserLoginResources | cre8magic",
    "keywords": "Class MagicUserLoginResources Namespace ToSic.Cre8magic.UserLogins Assembly ToSic.Cre8magic.Client.Oqtane.dll public record MagicUserLoginResources Inheritance object MagicUserLoginResources Properties Login public string Login { get; } Property Value string Logout public string Logout { get; } Property Value string Title public string Title { get; } Property Value string"
  },
  "api/ToSic.Cre8magic.UserLogins.MagicUserLoginSpell.html": {
    "href": "api/ToSic.Cre8magic.UserLogins.MagicUserLoginSpell.html",
    "title": "Class MagicUserLoginSpell | cre8magic",
    "keywords": "Class MagicUserLoginSpell Namespace ToSic.Cre8magic.UserLogins Assembly ToSic.Cre8magic.Client.Oqtane.dll public record MagicUserLoginSpell : MagicSpellBase Inheritance object MagicInheritsBase MagicSpellBase MagicUserLoginSpell Inherited Members MagicSpellBase.PageState MagicSpellBase.Name MagicSpellBase.Debug MagicInheritsBase.Inherits Extension Methods MagicSpellExtensions.Refill<TSpell>(TSpell?, PageState) MagicSpellExtensions.Refill<TSpell, TWith>(TSpell?, TWith?) MagicSpellExtensions.With<TSpell>(TSpell?, PageState, string?) MagicSpellExtensions.With<TSpell, TWith>(TSpell?, TWith?)"
  },
  "api/ToSic.Cre8magic.UserLogins.html": {
    "href": "api/ToSic.Cre8magic.UserLogins.html",
    "title": "Namespace ToSic.Cre8magic.UserLogins | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.UserLogins Classes MagicUserLoginResources MagicUserLoginSpell Interfaces IMagicUserLoginKit"
  },
  "api/ToSic.Cre8magic.Users.IMagicUserService.html": {
    "href": "api/ToSic.Cre8magic.Users.IMagicUserService.html",
    "title": "Interface IMagicUserService | cre8magic",
    "keywords": "Interface IMagicUserService Namespace ToSic.Cre8magic.Users Assembly ToSic.Cre8magic.Client.Oqtane.dll public interface IMagicUserService Methods User(PageState) MagicUser User(PageState pageState) Parameters pageState PageState Returns MagicUser"
  },
  "api/ToSic.Cre8magic.Users.MagicUser.html": {
    "href": "api/ToSic.Cre8magic.Users.MagicUser.html",
    "title": "Class MagicUser | cre8magic",
    "keywords": "Class MagicUser Namespace ToSic.Cre8magic.Users Assembly ToSic.Cre8magic.Client.Oqtane.dll public record MagicUser Inheritance object MagicUser Constructors MagicUser(PageState) Note: needs a custom constructor because the property PageState should be internal public MagicUser(PageState pageState) Parameters pageState PageState Properties DisplayName The display name of the user. public string? DisplayName { get; } Property Value string The display name or null if the user is anonymous. Email The email address of the user. public string? Email { get; } Property Value string The email address or null if the user is anonymous. Id The User ID as specified in the DB. public int Id { get; } Property Value int The ID or 0 (zero) if user is anonymous. IsAnonymous Is the user anonymous (not authenticated)? public bool IsAnonymous { get; } Property Value bool IsAuthenticated Is the user authenticated (not anonymous)? public bool IsAuthenticated { get; } Property Value bool IsRegistered public bool IsRegistered { get; } Property Value bool MayAdminCurrentPage public bool MayAdminCurrentPage { get; } Property Value bool MayEditCurrentPage public bool MayEditCurrentPage { get; } Property Value bool OqtaneUser The underlying Oqtane User object. public User? OqtaneUser { get; } Property Value User The object or null if the user is not authenticated. Username The username of the user. public string? Username { get; } Property Value string The username or null if the user is anonymous."
  },
  "api/ToSic.Cre8magic.Users.MagicUserSpell.html": {
    "href": "api/ToSic.Cre8magic.Users.MagicUserSpell.html",
    "title": "Class MagicUserSpell | cre8magic",
    "keywords": "Class MagicUserSpell Namespace ToSic.Cre8magic.Users Assembly ToSic.Cre8magic.Client.Oqtane.dll public record MagicUserSpell : MagicSpellBase Inheritance object MagicInheritsBase MagicSpellBase MagicUserSpell Inherited Members MagicSpellBase.PageState MagicSpellBase.Name MagicSpellBase.Debug MagicInheritsBase.Inherits Extension Methods MagicSpellExtensions.Refill<TSpell>(TSpell?, PageState) MagicSpellExtensions.Refill<TSpell, TWith>(TSpell?, TWith?) MagicSpellExtensions.With<TSpell>(TSpell?, PageState, string?) MagicSpellExtensions.With<TSpell, TWith>(TSpell?, TWith?)"
  },
  "api/ToSic.Cre8magic.Users.UserExtensions.html": {
    "href": "api/ToSic.Cre8magic.Users.UserExtensions.html",
    "title": "Class UserExtensions | cre8magic",
    "keywords": "Class UserExtensions Namespace ToSic.Cre8magic.Users Assembly ToSic.Cre8magic.Client.Oqtane.dll public static class UserExtensions Inheritance object UserExtensions Methods UserMayEditCurrentPage(PageState) Quickly ask the PageState if the user is allowed to edit the current page. Typically used to decide if certain buttons or information should be shown. public static bool UserMayEditCurrentPage(this PageState pageState) Parameters pageState PageState Returns bool"
  },
  "api/ToSic.Cre8magic.Users.html": {
    "href": "api/ToSic.Cre8magic.Users.html",
    "title": "Namespace ToSic.Cre8magic.Users | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Users Classes MagicUser MagicUserSpell UserExtensions Interfaces IMagicUserService"
  },
  "api/ToSic.Cre8magic.Utils.DictionaryExtensions.html": {
    "href": "api/ToSic.Cre8magic.Utils.DictionaryExtensions.html",
    "title": "Class DictionaryExtensions | cre8magic",
    "keywords": "Class DictionaryExtensions Namespace ToSic.Cre8magic.Utils Assembly ToSic.Cre8magic.Client.Oqtane.dll public static class DictionaryExtensions Inheritance object DictionaryExtensions"
  },
  "api/ToSic.Cre8magic.Utils.GetKeep-2.html": {
    "href": "api/ToSic.Cre8magic.Utils.GetKeep-2.html",
    "title": "Class GetKeep<TResult, TCompare> | cre8magic",
    "keywords": "Class GetKeep<TResult, TCompare> Namespace ToSic.Cre8magic.Utils Assembly ToSic.Cre8magic.Client.Oqtane.dll Get-or-Keep helper. Will expect a second return value when generating the value, which it will ask for comparison every time it's accessed again. public class GetKeep<TResult, TCompare> where TResult : class Type Parameters TResult TCompare Inheritance object GetKeep<TResult, TCompare> Properties IsValueCreated Determines if value has been created. The name IsValueCreated is the same as in a Lazy() object public bool IsValueCreated { get; } Property Value bool Methods Get(Func<(TResult Result, TCompare Compare)>, Func<TResult?, TCompare?, bool>) public TResult Get(Func<(TResult Result, TCompare Compare)> getter, Func<TResult?, TCompare?, bool> keep) Parameters getter Func<(TResult Result, TCompare Compare)> keep Func<TResult, TCompare, bool> Returns TResult GetAsync(Func<Task<(TResult Result, TCompare Compare)>>, Func<TResult?, TCompare?, bool>) public Task<TResult> GetAsync(Func<Task<(TResult Result, TCompare Compare)>> getter, Func<TResult?, TCompare?, bool> keep) Parameters getter Func<Task<(TResult Result, TCompare Compare)>> keep Func<TResult, TCompare, bool> Returns Task<TResult>"
  },
  "api/ToSic.Cre8magic.Utils.GetKeepByPageId-1.html": {
    "href": "api/ToSic.Cre8magic.Utils.GetKeepByPageId-1.html",
    "title": "Class GetKeepByPageId<T> | cre8magic",
    "keywords": "Class GetKeepByPageId<T> Namespace ToSic.Cre8magic.Utils Assembly ToSic.Cre8magic.Client.Oqtane.dll public class GetKeepByPageId<T> where T : class Type Parameters T Inheritance object GetKeepByPageId<T> Methods Get(PageState, Func<T>) public T Get(PageState pageState, Func<T> create) Parameters pageState PageState create Func<T> Returns T GetAsync(PageState, Func<Task<T>>) public Task<T> GetAsync(PageState pageState, Func<Task<T>> create) Parameters pageState PageState create Func<Task<T>> Returns Task<T>"
  },
  "api/ToSic.Cre8magic.Utils.Logging.CodeRef.html": {
    "href": "api/ToSic.Cre8magic.Utils.Logging.CodeRef.html",
    "title": "Class CodeRef | cre8magic",
    "keywords": "Class CodeRef Namespace ToSic.Cre8magic.Utils.Logging Assembly ToSic.Cre8magic.Client.Oqtane.dll Reference to code - containing the path to the file, the method name and the line in the code. [InternalApi_DoNotUse_MayChangeWithoutNotice(\"this is just fyi\")] public class CodeRef Inheritance object CodeRef Constructors CodeRef(bool, string, string, int) This constructor should be called without params, so that the compiler automatically injects all values. public CodeRef(bool autoPickup = true, string cPath = null, string cName = null, int cLine = 0) Parameters autoPickup bool Dummy parameter just to have a different signature. cPath string auto pre filled by the compiler - the path to the code file cName string auto pre filled by the compiler - the method name cLine int auto pre filled by the compiler - the code line CodeRef(string, string, int) Default constructor to set the values public CodeRef(string cPath, string cName, int cLine) Parameters cPath string cName string cLine int Fields Line Line of code where the code was running public int Line Field Value int Name Name of the method/property accessed public string Name Field Value string Path Path to the code file public string Path Field Value string"
  },
  "api/ToSic.Cre8magic.Utils.Logging.LogRoot.html": {
    "href": "api/ToSic.Cre8magic.Utils.Logging.LogRoot.html",
    "title": "Class LogRoot | cre8magic",
    "keywords": "Class LogRoot Namespace ToSic.Cre8magic.Utils.Logging Assembly ToSic.Cre8magic.Client.Oqtane.dll public class LogRoot Inheritance object LogRoot Properties Depth [JsonIgnore] public int Depth { get; set; } Property Value int Entries public IEnumerable<object?> Entries { get; } Property Value IEnumerable<object>"
  },
  "api/ToSic.Cre8magic.Utils.Logging.html": {
    "href": "api/ToSic.Cre8magic.Utils.Logging.html",
    "title": "Namespace ToSic.Cre8magic.Utils.Logging | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Utils.Logging Classes CodeRef Reference to code - containing the path to the file, the method name and the line in the code. LogRoot"
  },
  "api/ToSic.Cre8magic.Utils.PageStateSecurityExtensions.html": {
    "href": "api/ToSic.Cre8magic.Utils.PageStateSecurityExtensions.html",
    "title": "Class PageStateSecurityExtensions | cre8magic",
    "keywords": "Class PageStateSecurityExtensions Namespace ToSic.Cre8magic.Utils Assembly ToSic.Cre8magic.Client.Oqtane.dll public static class PageStateSecurityExtensions Inheritance object PageStateSecurityExtensions"
  },
  "api/ToSic.Cre8magic.Utils.StringExtensions.html": {
    "href": "api/ToSic.Cre8magic.Utils.StringExtensions.html",
    "title": "Class StringExtensions | cre8magic",
    "keywords": "Class StringExtensions Namespace ToSic.Cre8magic.Utils Assembly ToSic.Cre8magic.Client.Oqtane.dll public static class StringExtensions Inheritance object StringExtensions"
  },
  "api/ToSic.Cre8magic.Utils.html": {
    "href": "api/ToSic.Cre8magic.Utils.html",
    "title": "Namespace ToSic.Cre8magic.Utils | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic.Utils Namespaces ToSic.Cre8magic.Utils.Logging Classes DictionaryExtensions GetKeepByPageId<T> GetKeep<TResult, TCompare> Get-or-Keep helper. Will expect a second return value when generating the value, which it will ask for comparison every time it's accessed again. PageStateSecurityExtensions StringExtensions"
  },
  "api/ToSic.Cre8magic.html": {
    "href": "api/ToSic.Cre8magic.html",
    "title": "Namespace ToSic.Cre8magic | cre8magic",
    "keywords": "Namespace ToSic.Cre8magic Namespaces ToSic.Cre8magic.Act The starting point for your code. Contains the MagicAct and more. ToSic.Cre8magic.Analytics ToSic.Cre8magic.Breadcrumbs ToSic.Cre8magic.Containers ToSic.Cre8magic.Languages ToSic.Cre8magic.Links ToSic.Cre8magic.Menus ToSic.Cre8magic.OqtaneBs5 ToSic.Cre8magic.PageContexts ToSic.Cre8magic.Pages ToSic.Cre8magic.Spells ToSic.Cre8magic.Tailors ToSic.Cre8magic.Themes ToSic.Cre8magic.Tokens ToSic.Cre8magic.UserLogins ToSic.Cre8magic.Users ToSic.Cre8magic.Utils Classes MagicConstants MagicTokens"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Test Index Main - in pages | cre8magic",
    "keywords": "Test Index Main - in pages test"
  },
  "index.html": {
    "href": "index.html",
    "title": "cre8magic for Oqtane  Professional Theme Design | cre8magic",
    "keywords": "cre8magic for Oqtane  Professional Theme Design \uD83E\uDE84\uD83E\uDE84\uD83E\uDE84 Create Magic / Stunning / Amazing Designs on Oqtane \uD83E\uDE84\uD83E\uDE84\uD83E\uDE84 Oqtane is a Blazor based platform to create awesome solutions. It is heavily inspired by the Site/Page/Module model used in DNN. So it's almost ready to create awesome websites and CMS solutions. But there are two missing pieces () to create amazing websites: Real Content-Management features - which can be done with the extension 2sxc Tools to make designing themes fast and professional - enter: cre8magic cre8magic makes Oqtane Designer-Friendly As a designer, you need certain tools and workflows to be efficient, such as: the ability to make a small change and then reload the page to see the result the need to focus on the what (like the design), without wasting time on the how (like C# code to create the menu) the ability to create variations of your work, such as other layouts which are similar every tool you add (such as cre8magic) should help, but never restrict These aspects are important for the productivity of every designer. Now if you've worked with Oqtane (or Blazor for that matter) you will quickly see that this is not possible. This means you can whatever you want, but there is a lot of code involved, and a lot of time-consuming restarts. cre8magic takes care of all these problems \uD83D\uDE80 cre8magic combines very simple Razor and lets you do everything through settings. Most layouts have very similar HTML, but do vary a bit. For example, it could have different CSS classes to give it the look you need or a different logo file. imagine tweaking this at runtime (without compiling) \uD83D\uDE0F Overview This is how cre8magic enhances Oqtane so that your Theme can focus on the design: The resulting page will usually have something like this: \uD83D\uDC49\uD83C\uDFFE Discover how it works See a Working Example and Get Started Since this is a library, just reading the docs won't cut it. It's best to see this in action on a real-life example. Try the ToShine Theme Template, it will make things much easier to understand. \uD83D\uDC49\uD83C\uDFFC See 2shine Theme Template \uD83D\uDC49\uD83C\uDFFC See Get Started What's in the Magic Box Magic Settings: A Settings / Configuration System \uD83D\uDC49\uD83C\uDFFE see Magic Settings \uD83D\uDC49\uD83C\uDFFE see Settings JSON file \uD83D\uDC49\uD83C\uDFFE see JSON schema Magic Page Context Magic Tailor with Values, Classes and more using Tokens Magic Languages Magic Menu Magic Razor Base Classes These are the important base classes which your Razor files will inherit. All have in common, that they know about the theme-wide Settings and provide helper methods to get things done easily and quickly, with as little code as possible. Theme / Container Level Base Classes MagicTheme - the foundation for Themes MagicContainer - the foundation for Containers Important Base Controls / Components MagicLanguages is the base for the languages menu MagicBreadcrumbs is the base for the breadcrumbs MagicMenuRoot is the base for menu entry point, loading the configuration, nodes etc. MagicMenuBase is the base for each menu type, like Horizontal, Vertical, Mobile, ... MagicLogin is the base for login/logout icons and texts Generic Base Controls / Base Components These are meant for any other custom controls that you have. MagicControl is for razor controls that has the Octane API (it inherits from ThemeControlBase) MagicComponent is for razor controls with just the basic Razor API (inherits from ComponentBase) Magic Razor Controls / Components These are standalone controls for you to use, which you will normally just use but not inherit, as they already have their HTML output or something. Anything we refer to as a Control inherits from the Oqtane ThemeControlBase, while things we refer to as a Component inherit from the .net ComponentBase. Functional Controls / Components MagicOqtaneControlPanel a control which adds the main control panel for admins MagicContextAndSettings a wrapper used in every theme to ensure Magic Page Context and MagicSettings work Debug and Error Handling MagicExceptions a control showing important errors to admins MagicMenuDebug a debug helper to see what configuration a menu has and why MagicLanguagesDebug a debug helper to see what configuration the languages have MagicThemeDebug debug helper to see all the current settings on this theme"
  },
  "library/contribute/architecture.html": {
    "href": "library/contribute/architecture.html",
    "title": "cre8magic Internal Architecture | cre8magic",
    "keywords": "cre8magic Internal Architecture This document should explain the internal structures of cr8magic, so that developers can understand how it works and how to extend it. Overview For the architecture there are a few things to consider: Stable external APIs Consistent internal APIs to make this fairly complex thing easy to understand Main Paradigms For the Internal Architecture Composition over Inheritance We try to avoid inheritance as much as possible, and instead use composition. This makes it easier to understand and extend the system. Plain Vanilla Blazor Components We use ComponentBase instead of ThemeBase etc. This is a consequence of Composition over Inheritance. Read-Only Record Objects We use read-only record objects for state management. For example, a MagicSettings object is a read-only record object. This has many benefits, especially that it will be immutable and not cause side-effects. Interfaces instead of Objects We prefer to use interfaces instead of objects. This makes it easier to understand and extend the system. Structure by Topic, not by Type We structure the code by topic, not by type. This makes it easier to understand and extend the system. Autocaching in the Service We use autocaching in the service to make it faster and more efficient. Things to Consider We want developers to be able to use the services without having to use the Components. In addition, the settings mechanisms should be seamless, magical but still very easy to understand. Sample Best Practice Setup by Example of the Menu IMagicMenuKit will be the object that contains everything to do with the menu. Internal.IMagicMenuService will be the service that contains the logic to get the Kit. IMagicAct is the main entry point which is usually used to call the service. MagicMenuSettingsData (record) is the data object that is used for settings which can be stored. This object is usually not used the outside, as the outside will use the MagicMenuSettings (without the Data). MagicMenuSettings (record) will be the settings object that is used to configure what the service should provide. It extends the MagicMenuSettingsData and adds some additional properties, like the PartName which would be used to retrieve named settings. This object will usually be provided to the MagicAct to get everything set up. After the setup it will also be found on the .Settings property of the MagicMenuKit. After the setup it will have more values filled (from the MagicMenuSettingsData). Design MagicMenuBlueprints ... MagicMenuBlueprintPart ... TODO: NAMING NOT FINAL MagicMenuTailor ... The /Menus/Components/MagicMenu is a primary or sample component for using the menu. It will expect a Settings parameter which is the MagicMenuSettings. It will usually use the MagicAct to prepare the MagicMenuKit It will then use the MagicMenuKit to iterate the data, and render the menu. Settings Structures IMagicSettingsService is the internal object which manages/provides the settings. IMagicSettingsSource (of which there are many) is the object that can provide settings. The MagicSettingsSourceJson is an example of this. Sources contain a Catalog(...) method to retrieve the MagicSettingsCatalog MagicSettingsCatalogsLoader will collect all the Sources and provide them to the IMagicSettingsService. ... Settings Catalog and Structure A Catalog contain all the settings which can be requested by any part of the system. It follows two important conventions: Flat Structure with Topic first (e.g. Themes, ThemeDesigns Menus, MenuBlueprints, Breadcrumbs, ...) Each of these Settings Groups will have a dictionary of settings, so each section can contain multiple named settings. Everything is a record object, so it's immutable and can't cause side-effects. Everything inside the catalog should support the ICanClone<T> interface, so these records can be duplicated & modified easily. The catalog always follows the following conventions A ThemeSettings (of which there can be many) is used to configure a theme and (for example) determine which parts should be shown and where they can find their settings. Menus contains menu settings MenuBlueprints contains menu design settings Settings Json ...usually theme.json Specials like = inherits Internally"
  },
  "library/contribute/index.html": {
    "href": "library/contribute/index.html",
    "title": "Contributing Code | cre8magic",
    "keywords": "Contributing Code Tip This is still a work in progress. Setup The Solution is a Visual Studio 2022 solution. It has a few special things to know: The core project is ToSic.Cre8magic.Client Most UI tests are found in the Module ToSic.Module.Cre8magicTests. Testing in the Browser Place the module on a page and select various tests. If you are logged in, you can also save the configuration so the same test will be shown when you revisit the page. The reason we're doing this is because various tests will behave differently, depending on the theme around it. So this allows us to place the module on pages with different themes and see how it behaves. Important Conventions Group by Topic Each topic should have its own folder. eg. Menus, Breadcrumbs etc. Internal as Much as Possible Anything that is really not needed for the public use should be as internal as possible. Anything internal that can be internal should be marked as internal ...to really protect the public API surface. Anything internal should be in a folder Internal in the root or any topic based folder. ...this will be filtered out by the docs. (TODO) Really internal objects should not be named Magic... it's shorter and we can spot internal stuff + spot leaks in the docs. Note that this doesn't apply to internal implementations of interfaces, which should be named after the interface."
  },
  "library/contribute/tests-test-module.html": {
    "href": "library/contribute/tests-test-module.html",
    "title": "The Test Module and How To Use It | cre8magic",
    "keywords": "The Test Module and How To Use It Part of the dev solution is a module called ToSic.Module.Cre8magicTests. This module is used to test various aspects of the system, and to ensure that everything works as expected. Basically you should compile it into your dev Oqtane an add it to pages to test various aspects of the system."
  },
  "library/contribute/tests-unit-tests.html": {
    "href": "library/contribute/tests-unit-tests.html",
    "title": "TODO: Document Unit Tests | cre8magic",
    "keywords": "TODO: Document Unit Tests"
  },
  "library/get-started/index.html": {
    "href": "library/get-started/index.html",
    "title": "Get Started | cre8magic",
    "keywords": "Get Started with cre8magic Install cre8magic As of 2022-10 cre8magic is still beta, so you would need to get it from github and compile. In 2022-12 2024-12 we plan to release it on nuget."
  },
  "library/guides/index.html": {
    "href": "library/guides/index.html",
    "title": "cre8magic  Guides for Special Topics | cre8magic",
    "keywords": "cre8magic  Guides for Special Topics ... History ..."
  },
  "library/guides/oqtane-cascading-parameters.html": {
    "href": "library/guides/oqtane-cascading-parameters.html",
    "title": "Oqtane Cascading Parameter and How to Use it | cre8magic",
    "keywords": "Oqtane Cascading Parameter and How to Use it Blazor uses a concept called Cascading Parameters to pass data from a parent component to a child component. Here you'll learn how this works, how Oqtane uses it, and how this affects your work with cre8magic. Cascading Parameters in Blazor In short, a parent component can prepare an object and pass it down to a child component. The parent would do something like this: // ParentComponent.razor @code { private ThemeInfo theme = new() { ButtonClass = \"btn-success\" }; private void ChangeToDarkTheme() { theme = new() { ButtonClass = \"btn-secondary\" }; } } <CascadingValue Value=\"theme\"> <ChildComponent /> </CascadingValue> And the child component would receive it like this: // ChildComponent.razor @code { [CascadingParameter] ThemeInfo Theme { get; set; } }  For in-depth understanding, read the official docs on Cascading Parameters. Oqtane and Cascading Parameters Oqtane uses this specifically to tell components about the current page, site, module and other context information. Specifically The PageState object is passed down to all components in the page The ModuleState object is passed down to all things module related - like the container or the module itself Note that SiteState is not passed down, as it's provided as a service using dependency injection. So any component which wants to know the PageState must do this: @code { [CascadingParameter] PageState PageState { get; set; } } Tip It's important to be aware that this value can change, and that it's not available before OnParametersSet is called. Oqtane and Inheritance over Composition Oqtane started with a design where components would inherit from a base class. So if you inherit from a typical Oqtane component, you'll get the PageState (and sometimes ModuleState) properties for free. This is the case for components which inherit from: ThemeBase and all derived components ModuleBase and all derived components ContainerBase and derived components such as ModuleTitle, ModuleActions, DefaultContainer etc. ThemeControlBase (inherits ThemeBase) and derived components such as ControlPanel, Login, MenuBase etc. Get PageState when Inheriting from ComponentBase Tip cre8magic  strongly believes in Composition over Inheritance as the pattern of choice. This means that you should not inherit from an Oqtane base class but instead inherit from ComponentBase. If you inherit from ComponentBase your code will look like this: // Note: this next line is not necessary, but we recommend it for clarity @inherits ComponentBase @code { [CascadingParameter] PageState PageState { get; set; } } Updated 2024-11-29 / Oqtane 6.0"
  },
  "library/guides/oqtane-page-state.html": {
    "href": "library/guides/oqtane-page-state.html",
    "title": "Oqtane PageState and How to Use it | cre8magic",
    "keywords": "Oqtane PageState and How to Use it The Oqtane PageState is an object which the platform Oqtane updates continuously and passes on to all components on the page. Here you'll learn what the PageState is, and how to use it in different scenarios. What is the Oqtane PageState Internally Oqtane creates the PageState object and updates it whenever the page changes. It contains various things such as: current-page information such as the current page, list of modules on it etc. list of all pages etc. site information to access ID, URL, etc. request information such as url parameters This object is provided by Oqtane automatically as a CascadingParameter. Tip Most operations in cre8magic will require the PageState object. There are a few ways to access it, explained below. Get the PageState If you inherit from any standard Oqtane component (not recommended), you can access the PageState object directly. This is because these components are already set up to receive the PageState object. Tip cre8magic  strongly believes in Composition over Inheritance as the pattern of choice. This means that you should not inherit from an Oqtane base class but instead inherit from ComponentBase. To access the PageState from any normal component, just add this section to your file which inherits from ComponentBase: @inherits ComponentBase @code { [CascadingParameter] PageState PageState { get; set; } } Use the PageState to get a Kit from the MagicAct Almost all operations in cre8magic require a Kit object. This is created for you by the IMagicAct service, which usually needs the PageState to figure out the context. There are two ways that the MagicAct can get the PageState: Directly in the request - there are a few ways to do this Provide it in the theme, so that all components can magically have it (less code) Pass the PageState to the MagicAct in the Call Since there will be various scenarios where you need to pass the PageState to the MagicAct, we have created a few ways to do this. The most simple one creates a new MagicMenuSpell and sets the PageState property: @{ var menuKit = MagicAct.MenuKit(new() { PageState = PageState }); } In other scenarios you may already have a MagicMenuSpell object, but want to extend it with the PageState: @code { // The PageState provided by Oqtane [CascadingParameter] PageState PageState { get; set; } // The Settings handed into this component as a required parameter (so it's never null) [Parameter, EditorRequired] MagicMenuSpell Settings { get; set; } } @{ // Extend the existing settings with the PageState using the records-with syntax var menuKit = MagicAct.MenuKit(Settings with { PageState = PageState }); } Tip The snippet above uses the with statement to create a new object with the PageState property set. This is a core feature of the newer C# languages, and records are used extensively in cre8magic. But the most common scenario is that you might have a MagicMenuSpell object. Since it could also be null, the with statement above would fail. To make things easier, we created an extension method to allow this syntax: @code { // The PageState provided by Oqtane [CascadingParameter] PageState PageState { get; set; } // The Settings handed into this component; NOT required, so it could be null [Parameter] MagicMenuSpell? Settings { get; set; } } @{ // Extend the existing settings with the PageState using the records-with syntax var menuKit = MagicAct.MenuKit(Settings.With(PageState)); } Internally this does the same as the original with statement, but also creates a new object if it's null. Provide the PageState in the Theme (less code) The above examples are the fool-proof way of doing things, but it does add some plumbing which isn't exactly magical. Since advanced setups will usually have a cre8magic-aware Theme, which has some initialization code running, you can also provide the PageState there. // In your Theme.razor file @code { /// <summary> /// Get the Magic Act from the DI /// </summary> [Inject] public required IMagicAct MagicAct { get; set; } /// <summary> /// OnInitialized will run early (and once only). /// It also runs before OnInitializedAsync. /// </summary> protected override void OnInitialized() { base.OnInitialized(); // Provide the first PageState as early as possible. MagicAct.UsePageState(PageState); } /// <summary> /// This will run whenever any parameter changes - such as PageState. /// It also runs before OnParametersSetAsync. /// </summary> protected override void OnParametersSet() { base.OnParametersSet(); // Provide the latest PageState on every change MagicAct.UsePageState(PageState); } } The MagicAct \uD83C\uDFA9 will remember the PageState for you, so your components can now be simpler. You can now write this: @{ var menuKit = MagicAct.MenuKit(Settings); } ...instead of the fairly lengthy: @code { // The PageState provided by Oqtane [CascadingParameter] PageState PageState { get; set; } // The Settings handed into this component; NOT required, so it could be null [Parameter] MagicMenuSpell? Settings { get; set; } } @{ // Extend the existing settings with the PageState using the records-with syntax var menuKit = MagicAct.MenuKit(Settings.With(PageState)); } Tip When creating a theme which fully uses cre8magic, we recommend this approach. But when creating reusable components for others, you cannot be sure that they have configured the theme to proved the PageState, so your standalone-components should always be able to handle the PageState themselves. History ..."
  },
  "library/how-it-works.html": {
    "href": "library/how-it-works.html",
    "title": "cre8magic  How It Works | cre8magic",
    "keywords": "cre8magic  How It Works Below we'll give you an example of what you would normally have, and how it would be done with cre8magic. Example Problem: Smart Module Containers Let's assume you have a container which is a bunch of div tags and a bit of CSS. In this example we have two features we are using a special ID for CSS targeting (for special cases where we wish to have CSS for a very specific module) some CSS classes which could vary depending on certain factors - such as if it's unpublished to show something is wrong Classic Solution @inherits Oqtane.Themes.ContainerBase <div id='module-@ModuleState.ModuleId' class='to-shine-background-container py-4 @(CheckIfModulePublished() ? \"\" : \"module-unpublished\") @(ModuleState.UseAdminContainer ? \"to-shine-admin-container\" : \"...\")'> <div class=\"container\"> <Oqtane.Themes.Controls.ModuleActions/> <ModuleInstance/> </div> </div> @code { public bool CheckIfModulePublished() { return UserSecurity.ContainsRole(ModuleState.Permissions, PermissionNames.View, RoleNames.Everyone); } } Based on this example you can see, that there is a mix of logic and design which is hard to read hard for a designer to develop error prone hard to maintain Simple with cre8magic Here's how it works with cre8magic: @inherits MagicContainer <div id='@Value(\"Id\")' class='@Classes(\"div\")'> <div class=\"container\"> <Oqtane.Themes.Controls.ModuleActions/> <ModuleInstance/> </div> </div> For the system to know what it should do, there are Magic Settings which are easy to manage. Below we're only showing the settings relevant to this example, there are of course more: { \"themeDesigns\": { \"Default\": { // ...a lot of settings not relevant for this example... // Container Designs determine CSS classes on containers // The default/normal container \"container\": { \"classes\": \"theme-container py-4 demo-module-[Module.Id] demo-page-[Page.Id]\", \"isPublished\": [null, \"module-unpublished\"], \"isAdmin\": \"theme-container-admin app-admin-modal\", \"id\": \"module-[Module.Id]\" }, } } } The Magic in the Background cre8magic will do a bunch of things in the background, such as: Load configuration from the DB targeting the page (WIP) the DB targeting a branch in the menu (WIP) the DB targeting the site (WIP) JSON targeting all kinds of scenarios defaults in your code (not recommended) final defaults in cre8magic Flatten configurations to match the current theme Use names to find the configuration for the theme Use further names to find the configuration for each part, such as Menus, Breadcrumbs etc. Flatten all to the current scenario Broadcast these flattened Magic Settings from the Theme to all Controls Initialize the proper settings Broadcast these settings to all controls that are somewhere within the theme object tree Provide simple accessors The MagicTheme, MagicContainer, MagicControl etc. all pick up the settings automatically ...and have special APIs such as @Classes(...) helpers to retrieve the values Process Tokens Settings can contain tokens such as [Module.Id] which will be rendered into the final result TL;DR You got this far? Let's go back to home and start designing! \uD83D\uDC49\uD83C\uDFFE Home"
  },
  "library/index.html": {
    "href": "library/index.html",
    "title": "cre8magic  Oqtane Theme System | cre8magic",
    "keywords": "cre8magic  Oqtane Theme System services, components, and utilities for Oqtane Themes Introduction Creating awesome themes for any platform is a lot of work, and needs a lot of skill. There's Bootstrap to master, as well as HTML, CSS and JavaScript to conjure up. And then there's the platform-specific stuff to learn, such as Blazor and the intricacies of Oqtane itself. The cre8magic library is a collection of services, components, utilities and documentations that help you create themes for Oqtane with less effort and more fun. 2sic, the inventors of cre8magic, have been creating themes for more than 1'000 websites since 1999. That's a lot of experience packed together. Our goal was to ensure that every theme we create is as good as it can be, and that we can create it as fast as possible. Let's take a simple example: System-Menus. They usually show a bunch of links, some within the normal structure of the site, and some taken out of the normal navigation structure just for the footer. Typically these pages are officially \"hidden\" in the navigation, since we don't want them in the main menu, but still need to be accessible. This is how we would do it in cre8magic using the MagicMenu Oqtane Bootstrap5 component: @using ToSic.Cre8magic.OqtaneBs5 <!-- In this case: - 1 is home - 5 is a hidden page in the navigation (hence the !), of which want to show the children --> <MagicMenu Spell='new() { Pick = \"1, 5!/\" }' /> Now let's assume you need to Tailor the menu a bit more using a Blueprint. We need to add 'sys-nav' to the class of the <ul>: <MagicMenu Spell='new() { Pick = \"1, 5!/\" }' Blueprint='new() { Parts = new() { { \"ul\", new() { Classes = \"sys-nav\" }}}}' /> Then again, let's place all these settings in a central location called the Spell Book and just name this menu part \"System-Menu\": <MagicMenu Name=\"System-Menu\" /> TODO: PartName - maybe something better to keep BluePrint / Spell-Book separate? By just having a name, and no parts... Maybe rename the theme parts a PartMap or NameMap or Rename for the special cases in this case we could always use name - for anything and if there is a part-map, it would redirect, but normally you wouldn't do this. would also simplify API to Name and possibly BlueprintName - but TBH that could be done with the Rename section... which could then just have spell and blueprint as properties explain Planned structure Introduction (maybe inside overview? or before) Overview, explaining what's in the box - basically what things it can solve Get Started - step-by-step guide to get started and simple use case Acts Common Setup Magic Breadcrumbs Magic Languages Magic Links ? Magic Logos Magic Menus Magic Page Context Magic Pages ? Magic To-Top SEO & Analytics Magic Analytics Magic Sitemap Razor Components Magic Themes Magic \"Buttons\" - needs better name Magic OqtaneBs5 Razor Components Foundation Magic Act Magic Blueprints Magic Tailors Magic Spells Magic Spells Book Magic Meta-Settings - needs better name / Magic Spells History Added in v0.0.1 2022-10 with 80% coverage of what DDR Menu had in DNN"
  },
  "library/languages/magic-languages.html": {
    "href": "library/languages/magic-languages.html",
    "title": "Magic Languages | cre8magic",
    "keywords": "cre8magic  Magic Languages The languages need three things to work as expected: They need to know if they should show They need to know what languages to show and what labels to use They need to be styled cre8magic makes this happen using these parts: The theme.json which has all the configurations The themes section determines if the menu should show using parts.languages The themes section also has a languagesMin which would hide the languages if there are less than X languages (usually it needs at least 2) The languages section has configurations for what languages to show and what labels to use The themeDesigns section determines how it should look - ATM there is only one key languages-li since the rest has sufficient automatic class names to cover all known styling cases The Magic Settings which will parse the json and provide the parts we need The base Razor MagicLanguages prepares everything so you can inherit from it and create the output as needed How to Use Best check the reference implementation on 2shine Template Theme History All created in v0.0.1 2022-10"
  },
  "library/magic-menu/index.html": {
    "href": "library/magic-menu/index.html",
    "title": "cre8magic  Magic Menu System for Oqtane Themes | cre8magic",
    "keywords": "cre8magic  Magic Menu System for Oqtane Themes The cre8magic Menu System helps you create best-practice menus in Oqtane. Tip A simple top-level menu can be added just like this: <MagicMenu Settings='new() { Pick = \"/\" }'/> ...or if you have a theme.json file, all you need is: <MagicMenu Name=\"MainMenu\"/> Menus are used in Oqtane solutions as the main way to navigate the user through the website. A typical website will have a 1 main menu, 2 mobile menu, a 3 footer menu and possibly more. Each of these menus can have different requirements, such as: Data Selection: showing specific pages the top-level pages (main menu), exact IDs (footer) or showing all pages below the current page (sidebar) Drill-Down: show a different depth of pages, such as only the first level, or all levels below the current page... Interactive Behavior: behaving in a certain way, such as collapsing sub-menus Look and Feel: look a certain way, such as highlighting the current page Doing this all in your own code can be challenging and error-prone, which is why we created the Magic Menus. Magic Menus TL;DR The goal is that your menus are: configuration-based - through code or JSON mobile-friendly & reactive ARIA-Accessible use HTML5 and Bootstrap5 conventions respect user permissions highlight the current page easy to customize & flexible You can work with pre-built components such as MagicMenu \uD83E\uDDE9 or leverage the MagicMenuKit \uD83E\uDDF0 to build your own components. A very simple menu can be added just like this: @using ToSic.Cre8magic.OqtaneBs5 <MagicMenu Settings='new() { Pick = \"/\" }'/> How it Works The Magic Menu uses the cre8magic conventions. Tip This is what always happens in a nutshell: flowchart LR S([\"Settings \"]) --> PC[\"Prepare Data & Kit \uD83E\uDDF0\"] PC --> MC[\"Blazor Code \uD83D\uDD25\"] MC --> HTML[\"HTML \uD83C\uDF10\"] Settings  tell cre8magic  what to do. cre8magic  prepares data in a Kit \uD83E\uDDF0, which also has more tools. Blazor Code \uD83D\uDD25 (your code \uD83D\uDC68\uD83C\uDFFB\uD83D\uDCBB or a Magic Component \uD83E\uDDE9) will... ...produce the desired HTML \uD83C\uDF10. Each of these steps can be very simple or very complex, depending on your needs. How it Works - Very Basic Setup Let's start with the most basic setup of all: use the MagicMenu \uD83E\uDDE9 Component <MagicMenu> place all the settings directly into the tag only specify (pick) that we want the top level pages don't specify any design or behavior, so it will take Bootstrap5 defaults @using ToSic.Cre8magic.OqtaneBs5 <MagicMenu Settings='new() { Pick = \"/\" }'/> The output will be approximately like this: TODO: check/update with reality <ul class=\"navbar-nav\"> <li class=\"nav-item\"> <a class=\"nav-link\" href=\"/\">Home</a> </li> <li class=\"nav-item\"> <a class=\"nav-link\" href=\"/about\">About</a> </li> <li class=\"nav-item\"> <a class=\"nav-link\" href=\"/contact\">Contact</a> </li> </ul> Here's what actually happens under the hood: The Visible Code @using ToSic.Cre8magic.OqtaneBs5 tells Blazor that we want to use these controls. <MagicMenu .../> is a Blazor component provided by cre8magic  The Settings=\"...\" attribute is a parameter which is passed to the component. It expects a MagicMenuSpell object. Since Blazor knows the expected type, you can shorten it as new() { ... }. The Pick determines what pages to show in this menu. In this case, it's only the top-level pages, specified by /. The Invisible Code The MagicMenu Component \uD83E\uDDE9 will take the parameters and the Oqtane \uD83E\uDE78 PageState them pass them to the MagicAct \uD83C\uDFAD, which will initialize an internal MagicMenuService to: mix in default settings which were not specified, such as Show=True retrieve the MagicPages as specified by the Pick parameter build a MagicMenuKit \uD83E\uDDF0 which contains the pages and some tools to easily create the menu Then the MagicMenu Component \uD83E\uDDE9 will use the MagicMenuKit \uD83E\uDDF0 to create the desired HTML \uD83C\uDF10. It will detect that we want a Horizontal menu (default) And run various loops etc. combining the pages and the blueprint to create the HTML. will take the settings and prepare a Kit for you using some internal wizardry. The MagicMenuSettings  determine what pages should be shown - like \"top-level only\" flowchart LR S([\"Settings  or ...Name <br> (_all optional_)\"]) --> PC{\"Use <br> Comp. <br> ?\"} PC -- yes --> MC[\"MagicMenu \uD83E\uDDE9 Component <br> uses \uD83C\uDFAD & \uD83E\uDDF0\"] MC -- get --> MT[\"Magic Tailor \uD83E\uDDF5\"] MT -- magic \uD83E\uDE84 --> HTML[\"Blazor HTML \uD83D\uDD25\"] PC -- no --> MH(\"Magic Act \uD83C\uDFAD <br> (get MenuKit \uD83E\uDDF0)\") MH --> YC[\"Your Code \uD83E\uDDD1\uD83C\uDFFD\uD83D\uDCBB\"] YC -- magic \uD83E\uDE84 --> HTML MagicMenuSettings  determine what pages should be shown - like \"second level only with sub-pages\" The MagicAct \uD83C\uDFAD will take these settings and prepare a Kit for you using some internal wizardry. This MagicMenuKit \uD83E\uDDF0 contains the MagicPages and various tools to easily create any menu. Some code will then use this kit to create the desired HTML \uD83D\uDD25 Either use the pre-built MagicMenu \uD83E\uDDE9 component in OqtaneBs5 to quickly create a best-practice Bootstrap5 menu Or create your own Blazor component according to your needs How it Works - Advanced Setup with Tailor If you are using the MagicMenu \uD83E\uDDE9 component, it can optionally use the MagicMenuTailor \uD83E\uDDF5 to tweak the output in various scenarios without changing your code. You can also create custom components which use the MagicTailor \uD83E\uDDF5. The tailor also needs settings, so this looks a bit like this: flowchart LR subgraph s1[\"Magic Act \uD83C\uDFAD\"] ls[\"Load Settings \"] n1[\"Load Blueprints \uD83D\uDCD8<br>&amp; Magic Tailor \uD83E\uDDF5\"] gk[\"Provide Kit \uD83E\uDDF0 with Tailor \uD83E\uDDF5\"] end YC[\"<b>Component / Code &lt; / &gt;</b><br>Using \uD83E\uDDF0 / \uD83E\uDDF5\"] -- magic \uD83E\uDE84 --> HTML[\"Blazor HTML \uD83D\uDD25\"] ls --> n1 n1 --> gk s1 --> YC S([\"Settings  or ...Name <br> (_all optional_)\"]) --> s1 The optional MagicMenuTailor \uD83E\uDDF5 is a helper to tweak the output in various scenarios without changing your code. It is used by the MagicMenu \uD83E\uDDE9 component to allow for easy customization. You can also create your own Tailors \uD83E\uDDF5 to further customize the output. The optional MagicMenuBlueprints \uD83D\uDCD8 are used to configure the MagicMenuTailor \uD83E\uDDF5 to your needs. For example, you can specify HTML class for any tag such as <ul>, <li>, <a>, <span> ...or specify data-, title or any attributes for special cases You can also specify conditional classes to add if a node is active or not active, is in breadcrumb, etc. The optional MagicPackageSettings allows you to configure everything in a central location. This can be either in code or in a theme.json file. Intro Examples 1. Simple Top-Level Menu This bit of blazor code will create Simple Top-Level Bootstrap5 Menu with the default settings, respecting user permissions and highlighting the current page: @using ToSic.Cre8magic.OqtaneBs5 ... <MagicMenu Settings='new() { Pick = \"/\" }'/> ... TODO: PIC of output 2. Simple Sidebar Menu The following Oqtane component will create a sidebar menu showing the second and third levels with collapsing arrows and highlighting the current page: @using ToSic.Cre8magic.OqtaneBs5 <MagicMenu Settings='new() { Pick = \".//2+\", Variant = \"Vertical\" }'/> TODO: PIC of output 3. Coded Menu This example assumes you want full control over the output, and still want to use the cre8magic engine to reliably get the right pages, permissions and a simpler SOLID API which is more robust than the built in Oqtane API: TODO: 4. Menu with Configuration in JSON This example shows how you can configure the menu in a theme.json file: { \"menus\": { \"sidebar\": { \"start\": \".\", \"level\": 2, \"depth\": 2 } } } @using ToSic.Cre8magic.OqtaneBs5 <MagicMenu SettingsName=\"sidebar\"/> Note that this example skips the part in the theme were the json is loaded and applied. Challenges and Goals When we designed cre8magic Menus, we wanted to be sure that we're ticking all the right boxes. So these are the real-life challenges we wanted to solve: High-Quality Output following the latest Bootstrap5, accessibility, mobile-friendly and best-practice standards. Make a simple, best-practice API which can be used in code, but can scale up to components and centralized settings. Ensure that the menus are always respecting user permissions and the current page. Allow for easy customization of the output without changing the code. Follow SOLID principles and Composition-over-Inheritance to ensure that the code is maintainable and extendable. Settings: MagicMenuSettings These are the main settings. Settings for loading the configuration elsewhere PartName - the theme part name which can reference other settings/tailor-settings TODO: link to why you would use this SettingsName - name of the settings in the full configuration under Menus (or menus in JSON) TailorName - name of the tailor to apply WIP Blueprints - settings for the tailor in the full configuration under MenuBlueprints (or menuBlueprints in JSON) Settings to specify what to show Pick - where to start, eg. * for root, . for current page, 42 for page 42 Level - how many levels above the start to show, eg. -1 for one above, 2 for two below Depth - how many levels below the start to show, eg. 2 for two below Children Settings to specify how to show Variant - it is up to the code do determine what do do with this. The MagicMenu \uD83E\uDDE9 currently supports Vertical for a sidebar, Horizontal for a top menu and will create different outputs like collapsing features. Design - name of the design to use WIP Settings to specify Context PageState - required IF it is not already broadcast by the theme === A core challenge with any website is creating great menus. There are actually three distinct problems to solve: Managing multiple menus on the same page the main menu possibly a side-menu with sub-pages a footer menu for disclaimer and privacy multiple menus in the footer for mega-footers with many links Configuration for selecting the pages which should appear in the menu where to start (like a menu which start at level 2) what pages to show (like all the pages on level 2 - or only their children) how deep to go (do we show submenus?) Design for styling of each node based on the context is the current node selected? add active... is the current node a parent of the selected node? add is-parent... is the current node a dropdown for pages beneath it... Manage Multiple Menus The MagicMenu gives each menu a name, such as Main, Sidebar, Footer etc. You can determine these names in the Razor files. Each of these menus can then be configured in the JSON. By default, each menu will find it's configuration and it's design based on the same name. So the Main menu would take the configuration and design called Main. But you can also reconfigure this. For example, you could say that the Theme Sidebar will use the configuration TopLevelOnly for the Main menu. This is configured in the parts of the themes section of the JSON file. Menu Configuration The menu configuration determines some important aspects such as NEW WAct node to start from - eg. `` = root, . = current page, .. = parent, 42 = page 42 Children (necessary for root): /, ./, 42/ WAct to do from the start - like \"children\": true means \"begin with the children\" of the start-node WAct level to show - so \"start\": \".\", \"level\": -1 means to start one level above the current page How deep to go, so \"depth\": 2 would show the starting level and one more All this is configured in the menus section of the JSON. Pick Values These are accepted values of the node start: / root (actually all top-level pages) // same (not recommended, just for API consistency) //1 same (not recommended, just for API consistency) //2 all second level pages (not typical/recommended, just for API consistency) //1/ all second level pages (not typical/recommended, just for API consistency) //3 all third level pages (not typical/recommended, just for API consistency) . current page ./ children of the current page .// all root nodes above the current page (not useful, like /) .. parent of the current page (just that page) ../ children of the parent of the current page (this page and siblings) .//2 ancestor of the current page on the second-level .//2/ children of the ancestor of the current page on the second-level ..-1 identical to .. ..-2 up two levels 42 the page 42 42/ children of the page 42 5! the page 5 even if it's normally not visible in a menu 42, 5! combinations thereof The following parameters will also influence what is shown on the first level: \"start\": \".\", \"children\": true starts with children of the current page \"start\": \"42\", \"children\": true starts with children of page 42 - ideal for footer or system-menus \"start\": \".\", \"level\": 2 starts with the page on level 2 which is above the current page \"start\": \".\", \"level\": -1 starts with the page one level above the current page you can also combine start=. level=-1 and children=true for further desired effects Depth The depth must always be at least 1 and determines how many levels downwards the nodes are rendered. Menu Blueprints This is one of the most sophisticated bits of the JSON settings. You can configure this in the menuBlueprints section of the JSON. Note that this uses the Magic Classes with Tokens. Example: \"menuBlueprints\": { \"Mobile\": { \"ul\": { \"byLevel\": { \"1\": \"navbar-nav\", \"-1\": \"collapse theme-submenu-[Menu.Id]-[Page.Id]\" }, \"inBreadcrumb\": \"show\" }, \"li\": { \"classes\": \"nav-item nav-[Page.Id] position-relative\", \"hasChildren\": \"has-child\", \"isActive\": \"active\", \"isDisabled\": \"disabled\" }, \"a\": { \"classes\": \"nav-link mobile-navigation-link\", \"isActive\": \"active\" }, \"span\": { \"classes\": \"nav-item-sub-opener\", \"inBreadcrumb\": [ null, \"collapsed\" ] }, // Special target information (not really styling) usually on the span-tag \"data-bs-target\": \".theme-submenu-[Menu.Id]-[Page.Id]\" }, } This means a lot of things, but let's highlight some aspects: the surrounding <ul> tag will get the navbar-nav class at the first level; all others will get collapse and others the <ul> will also get a menu and page specific class because of the theme-submenu-[Menu.Id]-[Page.Id] which is useful for the collapse identification in bootstrap the <li> of each node will get some classes including an active if it's the current page, and has-child if it has children so that the bootstrap menu will do it's magic the <a> link itself will also have different classes based on active the <span> is used to show a +/- indicator using the nav-item-sub-opener ...and it will also get's collapsed if it's not in the breadcrumb (so it's only opened if a sub-page is the current page) and a special attribute used by bootstrap data-bs-target will have the same contents as the identifying class of the surrounding <ul> to ensure bootstrap will work Missing Features As of now you cannot filter out specific pages. For this you would still need to write your own code or construct your nav-tree for special cases. You cannot link to page in another language, as Oqtane doesn't really have this concept yet. History Added in v0.0.1 2022-10 with 80% coverage of what DDR Menu had in DNN"
  },
  "library/magic-meta-structure.html": {
    "href": "library/magic-meta-structure.html",
    "title": "cre8magic  Topic | cre8magic",
    "keywords": "cre8magic  Topic (teaser) About Intro Example - tabbed or boxed? A Component Example A Library Example Challenges and Goals"
  },
  "library/page-context/index.html": {
    "href": "library/page-context/index.html",
    "title": "Magic Context | cre8magic",
    "keywords": "cre8magic  Magic Page Context The Magic Context adds a bunch of classes to the <body> or a wrapper <div> tag which contain information about the current state. This allows you to then write CSS rules, which change the look / feel of the page based on certain aspects. Example The wrapper <div> could look like this: <div id=\"cre8magic-root\" class=\"page-35 page-root-29 page-parent-33 site-1 nav-level-3 theme-mainnav-variation-right theme-variation-centered\"> <!-- the contents of the page--> </div> This tells you a bunch of things such as: This is page #35 - allows you to do things like special colors for exactly this page The page is in the tree of the root #29 - so you could use special colors for all the pages in this branch The pages parent is #33 - again letting you write custom CSS We are on site #1 - in case you have different styles based on the site number We are currently on the nav-level 3 - this could affect your breadcrumb or something We are in a specific layout type and navigation type How this Works Basically all this happens automatically, if your json configuration has magicContext of something like this: { \"magicContext\": [ \"page-[Page.Id]\", \"page-root-[Page.RootId]\", \"page-parent-[Page.ParentId]\", \"site-[Site.Id]\", \"nav-level-[Menu.Level]\", \"theme-mainnav-variation-right\", \"theme-variation-[Layout.Variation]\" ] } You can of course add your own rules with other placeholders to make this happen. Configuration You can determine if this will be added to a <div> or the <body> using the setting magicContextInBody If it's on the body, it will be put there using JavaScript, so there may be a minimal flash-of-unexpected-styling if you put it in the div, it will always be there You can also change the id of the <div> tag if you want to change how your CSS behaves. The id can be set on the magicContextTagId Missing Features As of 2022-10 there are no magic context classes for languages yet, as Oqtane doesn't fully support Multi-Language. We'll add it as soon as possible. History Added in v0.0.1 2022-10"
  },
  "library/patterns.html": {
    "href": "library/patterns.html",
    "title": "Patterns | cre8magic",
    "keywords": "Patterns cre8magic strives to follow the best practices of software development. This includes the use of patterns and principles that have been proven to work well in the past. Tip Some of these patterns are very different from the patterns used in Oqtane. There are good reasons for this, which are explained in the respective sections. Settings > Service > Kit > Work ... Composition over Inheritance cre8magic prefers composition over inheritance. Warning  vs. \uD83D\uDCA7 This pattern used by cre8magic is seen as a best practice by the cre8magic team and by many experts in the community. Oqtane currently uses a different pattern, which is prioritizes inheritance. Plain Vanilla Blazor Components ...ComponentBase instead of ThemeBase etc. ...consequence of Composition over Inheritance. Read-Only Record Objects cre8magic uses read-only record objects for state management. For example, a MagicSettings object is a read-only record object. This has many benefits, especially that it will be immutable and not cause side-effects. Warning  vs. \uD83D\uDCA7 This pattern used by cre8magic is seen as a best practice by the cre8magic team and by many experts in the community. Oqtane currently uses a different pattern, which has mutable classes. Example of  vs. \uD83D\uDCA7 Oqtane's Page object is mutable, and can be changed at any time. You should never do this, and it can have severe side-effects. But the API doesn't prevent you from doing it. cre8magic's MagicPage record is immutable, and can never be changed. You can create new copies of it, but the original will always stay the same. Interfaces instead of Objects ... Structure by Topic, not by Type todo: diff than Oqtane ... Auto-Caching in the service... Plural Namespaces cre8magic uses plural namespaces for all services and objects. For example, Breadcrumbs or Languages Records as Function Parameters API stability update-safe ..."
  },
  "library/roadmap/history.html": {
    "href": "library/roadmap/history.html",
    "title": "Roadmap | cre8magic",
    "keywords": "Roadmap Working on v0.02 2024-11 Here we want to make it more architecturally sound, and more modular. Goal is that some developers may only want to use certain services to make their life easier. These people may not care about the settings system, projections or even styling system. But those automations should still exist for most projects that just want to get things done. So the goal is kind of the following - based on an example of the menu system: Services We probably need some primary service which will do most of the work, To ensure that our startup logic is able to retrieve other services as well... Factories Have a service - probably called ToSic.Cre8Magic.Pages.MagicPagesService - which is used to prepare the data for various use cases such as: Menu Breadcrumbs Sitemap Single pages which are smarter etc. These services should have a simple API but be able to do \"everything\" This should either be a named-params system Or a fluent API (TBD) Samples which just use the service, and custom Razor to do everything else. More Thoughts Probably remove the \"Client\" part in the namespace Probably make a topic based namespace system, not a model/services/controls system ? or the other way around? Unit tests? Possibly make smaller DLLs?, like a Core, A pages, etc. Version 0 2022-10-07 v0.0.2 Made menu design settings support inherit Added json schema and published to https://2sic.github.io/cre8magic/schemas/2022-10/theme.json First Beta v0.01 2022-10-05 This was the first internal release of the project. It was made to test various concepts such as: Initial release for use on blazor-cms.org Named settings for layouts, breadcrumbs, menus Named settings for the design of layouts, breadcrumbs, menus A bunch of base classes for Razor A bunch of services to make it happen MagicContext, MagicSettings, MagicConfigurations etc. Basically... Simple Bootstrap 5 Themes which can be easily customized without recompiling. Settings-System which projects the configuration(s) to the various themes and components. Creating various \"standard\" components that just do everything right. This system had some important shortcomings, such as: Black box - things magically worked - or didn't We tried to compensate a lot of this with logging, but that only helped if you already knew a lot of the systems internals."
  },
  "library/roadmap/index.html": {
    "href": "library/roadmap/index.html",
    "title": "Roadmap | cre8magic",
    "keywords": "Roadmap Working on v2 2024-11 As of 2022-10 cre8magic is still beta, so you would need to get it from github and compile. In 2022-12 we plan to release it on nuget."
  },
  "library/settings/index.html": {
    "href": "library/settings/index.html",
    "title": "cre8magic - Magic Settings Overview | cre8magic",
    "keywords": "cre8magic - Magic Settings Overview Magic Settings are a core building block of cre8magic. Basically anything you do, will start of with some settings - or some invisible defaults. Tip Magic Settings allow you to move 95% of the theme code into some kind of configuration. Quick Introduction Magic Settings are a way to provide settings to the various parts of cre8magic. Let's say you want to create a footer-menu, which only shows Home and Login. <!-- This is what you would do --> `<MagicMenu Settings='new () { Nodes = \"/, 5\" }' />` <!-- Note that the previous is just a shorthand for --> `<MagicMenu Settings='new MagicMenuSettings() { Nodes = \"/, 5\" }' />` Settings can also be provided in a central location, and just use the name of the settings: <!-- Get menu-settings called \"footer\" --> `<MagicMenu SettingsName=\"footer\" />` <!-- Get all settings for the part \"footer-menu\" --> `<MagicMenu PartName=\"footer-menu\" />` Settings are also used to get Kits so you can write your own code to do things, like this: var menuKit = MagicAct.MenuKit(new () { Nodes = \"/, 5\" }); Settings are also used when you don't provide them, in which case some minimal defaults are used: var menuKit = MagicAct.MenuKit(); Note Settings are used to specify what you want to do, and how you want to do it. On the other hand, Blueprints are used to customize the output using Tailors. So you could think of Blueprints as Design Settings but they are treated differently. Overview These are the things you should probably know: What settings can be used for each scenario How to provide settings in a central location How to provide settings by name or theme part name (TODO:) How to provide design settings (TODO:) How to provide PageState (TODO:) How settings work internally Settings for each Scenario Settings will differ depending on if you're creating a menu, a breadcrumb, a Magic Context, or something else. So for this you should look at the respective documentation. TODO: list all relevant parts Providing Settings Settings can be used directly in the code, like: var breadcrumbKit = MagicAct.BreadcrumbKit(new MagicBreadcrumbSettings { PageState = PageState, WithActive = true, WithHome = false, }); Or you can have settings prepared in a central location, and just use the name of the settings: var breadcrumbKit = MagicAct.BreadcrumbKit(PageState); The second way is especially useful when the identical code and components should result in different outputs depending on the scenario, since it allows you to change the settings in one place. For example, you could define that certain menus don't appear or look different within certain parts of your site. For this, see Providing Settings. Providing Named Settings TODO: Providing Settings by Theme Part Name TODO: How Settings Work Internally TODO: explain how settings are used internally Settings have a 2-level hierarchy, shown by the example of a breadcrumb: MagicBreadcrumbSettings would be the main settings which are used in your code. These settings have all the possible options, but also some properties which can only be set by code. For example, you can set a Designer which is a special object that can create some HTML. The MagicBreadcrumbSettingsData is the underlying class behind the MagicBreadcrumbSettings. It contains all the properties which can be stored externally, like in a JSON file or database. Levels of Indirection WIP Theme Variant Part in that Theme Variant Settings Design Settings Inheritance on every level Overview - old, json file... Basically the magic settings let you put a bunch of parameters in a JSON file. This file is then used by your Theme and it's Controls to determine what Blazor files to use (like what Template should be used for the menu) what to do with class=\"...\" or id=\"...\" in the HTML and much more \uD83D\uDE09 This basic principle allows you to create and tweak amazing designs without ever recompiling the Theme. It also allows you to create variations of your theme with the same Blazor files. Example JSON See settings-json to see an example file. The Configuration File The system works by creating a json file such as theme-settings.json. This is placed in your themes wwwroot folder like this: wwwroot/ToSic.Themes.BlazorCms/theme-settings.json Note that we don't use ...Client in the path, just the real namespace. Which file to use can be configured in the theme. Normally you would use the same file for all variations of your theme, but the important thing is that the theme must give some initial configuration object to the cre8magic Services. Here's how: Create the MagicPackageSettings This could be done anywhere, but I would place the code in the ThemeInfo.cs file: /// <summary> /// Default settings used in this package. /// They are defined here and given as initial values to the ThemeSettingsService in the Default Razor file. /// </summary> public static MagicPackageSettings ThemePackageDefaults = new() { // The package name is important, as it's used to find assets etc. PackageName = new ThemeInfo().Theme.PackageName, // The json file in the theme folder folder containing all kinds of settings etc. SettingsJsonFile = \"theme-settings.json\", }; Tell the Theme to Use these Settings Then in the theme, you should inherit from the MagicTheme base class and set the ThemePackageSettings like this: public override MagicPackageSettings ThemePackageSettings => ThemeInfo.ThemePackageDefaults; This would usually look a bit like this: public abstract class MyThemeBase : MagicTheme { public override List<Resource> Resources => new() { new() { ResourceType = Stylesheet, Url = $\"{ThemePath()}theme.min.css\" }, // Bootstrap generated with Sass/Webpack new() { ResourceType = Script, Url = $\"{ThemePath()}bootstrap.bundle.min.js\" }, // Bootstrap JS new() { ResourceType = Script, Url = $\"{ThemePath()}ambient.js\", }, // Ambient JS for page Up-button etc. }; /// <summary> /// The ThemePackageSettings must be set in this class, so the Settings initializer can pick it up. /// </summary> public override MagicPackageSettings ThemePackageSettings => ThemeInfo.ThemePackageDefaults; public override string Panes => string.Join(\",\", PaneNames.Default, PaneNameHeader); } that's it \uD83C\uDFFD How the Settings Work Internally the MagicSettingsService will be initialized automatically by the MagicTheme base class. It will then go and pick up the JSON file, parse it, do a bunch of magic and come back with a final MagicSettings object. This MagicSettings will then contain all the important settings for the current page/theme. It will also keep a reference to other settings such as Menus for which many configurations can exist. How the Settings are Broadcast A key feature of this system is that the settings are initially loaded in the theme, and then broadcast to all controls used in that theme. To make this happen, the theme must wrap everything in a MagicContextAndSettings tag: <MagicContextAndSettings Settings=\"Settings\"> Content </MagicContextAndSettings> This will do a few things Make sure that the inner content is only shown if Settings are loaded - otherwise show a loading settings... text Broadcast the MagicSettings with the name Settings to all child controls using CascadingValue. It will also ensure that the Magic Page Context is set on the page TODO: EXPLAIN SETTINGS MORE Continue... Then continue back to the \uD83D\uDC49\uD83C\uDFFE Home"
  },
  "library/settings/lookup.html": {
    "href": "library/settings/lookup.html",
    "title": "cre8magic - Magic Settings Lookup With Name WIP | cre8magic",
    "keywords": "cre8magic - Magic Settings Lookup With Name WIP WIP trying to document how the settings are looked up. Named Parts Every part can have a name. This name is used to look up the settings for the part. Goals Every part is named / identified ...and if not, a default name/identifier is used... The name is used to look up the spell The name is used to look up the blueprints Theme Variants can \"redirect\" the name(s) The settings can be reused and expanded by another name (@inherits) - maybe change to @import to also allow partial imports? Simple Use Case Let's look at a theme which has the name MainMenu. <MagicMenu Name=\"MainMenu\" /> The system will then use the MagicSpellsBook in the MagicThemePackage and look for: Menus (Spells) with the name MainMenu MenuBlueprints with the name MainMenu These will then be used to create the menu. Advanced Use Case with Multiple Theme Variants Let's say you have a theme with multiple variants, such as FixedWidth and FullScreen. In this case it could be that the MainMenu is different for each variant - and some things such as the SideMenu may not even appear. In most of these cases, the Razor will actually stay the same: <MagicMenu Name=\"MainMenu\" /> ...but the Settings-Lookup can have an additional step: Check the ThemeSpell in the SpellBook and look at the Parts-Map If the MainMenu is found in the Map, then check if there are renames. Let's assume that The FixedWidth theme maps the design to MainMenuFixedWidth and leaves the Spell-Settings as is The FullScreen leaves everything as is The new names are then used to find the Spells and Blueprints Notes / WIP Scenario: No Lookup - probably no name should be provided? Code contains all settings No lookup is desired! Fallback values should be applied if anything is missing Scenario: Lookup Main Name and maybe Merge - probably name should be provided Lookup is desired, by main name If not found, just use empty Fallback values should be applied if anything is missing Scenario: Lookup every section with Exact Names and maybe Merge - probably all names should be provided Lookup is desired, by exact names - Spell & Blueprint If section name not provided, use main-name... If not found, just use empty Fallback values should be applied if anything is missing How To Theme Variations One variation only todo Multiple Variations with Same Settings todo Multiple Variations with only a different Blueprint Create the default configuration For each name, make sure you create a theme with @inherits and the default configuration This will ensure that the \"new\" name is preserved."
  },
  "library/settings/provide-settings.html": {
    "href": "library/settings/provide-settings.html",
    "title": "cre8magic - Magic Settings and Prepared Settings | cre8magic",
    "keywords": "cre8magic - Magic Settings and Prepared Settings Magic Settings are a core building block of cre8magic. There are two basic ways to work with Magic Settings: With Direct Settings, you will specify the settings in your code to get some specific data from a service. Or you can have Prepared/Provided Settings in a central location, and just use these. Or you can have Named Settings in a central location, and just use the name of the settings. Or you can have Settings by Theme Part Name in a central location, and just use the name of the part. The scenarios above each add more levels of indirection. This could be confusing to start with, but very powerful once you understand it. Before we explain the details, let's look at some examples. Example Direct Settings vs. Prepared Settings 1. Direct Settings This example assumes you want to create a Breadcrumb, with all the code directly in your Blazor component. going from the home page to the current page you want the home page to be shown as the first node and you want the current page to be shown as the last node, but not as a link @{ var breadcrumbKit = MagicAct.BreadcrumbKit(PageState, new MagicBreadcrumbSettings { WithActive = true, WithHome = false, }); } <ol class=\"breadcrumb\"> @foreach (var item in breadcrumbKit.Pages) { @* ... *@ } </ol> Or when using a MagicBreadcrumb component: <MagicBreadcrumb Settings=\"new MagicBreadcrumbSettings { WithActive = true, WithHome = false }\" /> 2. Loaded Settings This example assumes that settings have been prepare for this control to use. So the code is simply: @* Breadcrumb using the settings from the catalog *@ @{ breadcrumbKit = MagicAct.BreadcrumbKit(PageState); } <ol class=\"breadcrumb\"> @foreach (var item in breadcrumbKit.Pages) { @* ... *@ } </ol> Or when using a MagicBreadcrumb component: <MagicBreadcrumb /> 3. Loaded Settings by Name The previous example didn't specify anything when retrieving the data. Now there are cases where the Prepared Settings use names. This may not be common for breadcrumbs, but typical for menus where you would have: a main menu showing all items starting from the home page a footer menu showing only a few pre-specified items In this case, you should know that these two things are equivalent: @{ breadcrumbKit = MagicAct.BreadcrumbKit(PageState); breadcrumbKit = = MagicAct.BreadcrumbKit(PageState, new() { SettingsName = \"default\" }); } Or when using a MagicBreadcrumb component: <MagicBreadcrumb /> <MagicBreadcrumb SettingsName=\"default\" /> Preparing / Providing Default Settings The settings are prepared and provided in a central location. Tip Since each Theme can have its own settings, the central location to prepare settings is in the Theme code. There are different ways to provide settings: You could just write your own code to keep all settings in one place. The theme code can setup the MagicAct with the settings. The theme code can load settings from a JSON file into the MagicAct The theme code could load settings from a database (not supported yet). Option 1: Just Write Some Shared Code This variant is not recommended, but included just for completeness. You could just have a class which provides the settings: namespace MyCompany.MyTheme.Ui public class MySettingsProvider { public static MagicBreadcrumbSettings BreadcrumbSettings => new() { WithActive = true, WithHome = false, }; } And then use it like this: @{ breadcrumbKit = MagicAct.BreadcrumbKit(PageState, MySettingsProvider.BreadcrumbSettings); } Option 2: Broadcast from Theme This is the first recommended way to provide settings. The settings can be managed centrally, but are still part of the Theme. In terms of Separation of Concerns, we still recommend placing the code which has the settings in it's own class (similar to the previous example). This is the code you would use in your theme: /// <summary> /// OnInitialized, make ure that cre8magic knows what settings this theme wants. /// </summary> protected override void OnInitialized() { base.OnInitialized(); MagicAct.UseSettingsProvider(p => p .Breadcrumbs.SetDefault(MySettingsProvider.BreadcrumbSettings) .Menus.SetDefault(MySettingsProvider.MenuSettings) .UserLogin.SetDefault(MySettingsProvider.UserLoginSettings) ); } And then use it like this: @{ breadcrumbKit = MagicAct.BreadcrumbKit(PageState); } 3. Load Settings from JSON This is the most flexible way to provide settings. It's quite nice, because you can change settings without recompiling your theme. This provides for a much nicer developer / designer experience. The setup requires these things: A JSON file in your theme's wwwroot folder. A MagicThemePackage object in your theme. TODO:"
  },
  "library/shared/do-inherit-from-componentbase.html": {
    "href": "library/shared/do-inherit-from-componentbase.html",
    "title": "| cre8magic",
    "keywords": "Tip cre8magic  strongly believes in Composition over Inheritance as the pattern of choice. This means that you should not inherit from an Oqtane base class but instead inherit from ComponentBase."
  },
  "library/tailor/index.html": {
    "href": "library/tailor/index.html",
    "title": "cre8magic  Magic Tailor | cre8magic",
    "keywords": "cre8magic  Magic Tailor The Magic Tailor system allows you to fine-tune the HTML output of Magic Components. It allows simple, generic components to be used in all kinds of scenarios, since the tailor can be configured using Blueprints. The Tailor will then take the Blueprints which apply to the current use case, and give you a simple API such as ...Classes(\"ul\") which will give you the classes for a ul tag. TODO: How the Magic Tailor Works TODO: cre8magic  Magic Values, Classes and More Almost all design work is done using very few changes to the HTML. The only thing we usually must do, is: set some id properties set some class properties - often based on the context (so the pane may need pane-is-empty) set some values - such as data-bs-toggle cre8magic makes this happen using these parts: The theme.json which has all the configurations The Magic Settings which will parse the json and provide the parts we need Various Desiger helpers which will do some magic and add context TODO: Tailors / Blueprints The Magic Tokens which will replace things such as [Page.Id] if it was used in class strings Simple helper methods such as Classes(name), Value(name) or Id(name) on all the Magic Razor base classes like the MagicMenu, MagicBreadcrumbs or MagicContainer How to Use Basically all your controls must usually do is write HTML along these lines: @inherits MagicContainer <!-- some code parts skipped for brevity --> <div id='@Id(\"container\")' class='@Classes(\"container\")'> <div class=\"container\"> <Oqtane.Themes.Controls.ModuleActions/> <ModuleInstance/> </div> </div> ...and of course make sure the values for the above mentioned container exist in the theme.json. Everything else just works magically. Razor API All the Magic* Razor controls have the following methods to make like easier: Classes(name) Value(name) Id(name) A few have some extra methods, such as these: The MagicTheme also has a PaneClasses(name) to also add something to change styling if the pane is empty Magic Tokens Most settings will be parsed through a tokens-engine which will convert all kinds of tokens such as [Page.Id] into their respective value. Note that each context is different. For example, when parsing settings at the page level, [Page...] tokens will work, but [Module...] tokens will not work. Note: The list of tokens is still work in progress Purpose of Magic Tokens The purpose of these tokens is for use in configurable values - such as classes on HTML tags. They are currently not going to give you all possible values, for eg. there is no [Module.Title] token since there is no good reason to use this in such scenarios. If you need those values in your HTML (eg. to create special hover-labels) you would just do that in Razor code. Site Tokens Site tokens work everywhere. As of now we have these site tokens: [Site.Id] - ID of the current site Theme Tokens Assets tokens work everywhere. As of now we have these assets tokens: [Theme.Url] - the url like Themes/your-theme-name for where your files should be note: it doesn't have leading or trailing slash, so you would use [Theme.Path]/Assets/logo.svg note: it also doesn't have wwwroot as that is never in the public URL Page Tokens Page tokens work everywhere. They are especially useful in creating menus. As of now we have these page tokens: [Page.Id] - ID of the current page [Page.ParentId] - ID of the pages parent page or none [Page.RootId] - ID of the root page in the tree leading to this page or none Module Tokens Module Tokens work on Containers only. As of now we have these module tokens: [Module.Id] - ID of the current module Module Type Information [Module.Namespace] - the name like Oqtane.Modules.HtmlText of the current module ideal to add to containers where you wish to have special styling for special types of modules this uses the namespace, without the final control name [Module.Control] - the control name like Index of the current module ideal to specify even more specific styling from the namespace the final control name ~[Module.Name]~ - the name like HtmlText of the current module (from the namespace, without the final control name) impossible to implement because each module will have different namespace conventions, so finding the real name isn't possible Layout Tokens TODO: Menu Tokens Menu Tokens work on Menus only. As of now we have these menu tokens: [Menu.Id] - ID of the menu which is normally randomly generated to ensure that each menu is unique for collapse/uncollapse [Menu.Level] - level of the menu which can be different for the page level, as menus that start at level 2 still have the first items on menu level 1 How it Works As of v0.1 2022-Q3 it's still a simple search-and-replace. We plan to use a more powerfull RegEx in the near future. History Magic Values were created in v0.1.0 2022-10 Magic Values were completely overhauled in v0.6 in 2024-12"
  },
  "library/terminology.html": {
    "href": "library/terminology.html",
    "title": "cre8magic Terminology WIP | cre8magic",
    "keywords": "cre8magic Terminology WIP MagicAct Kit Settings SettingsName ThemePackage Blueprint Blueprints BlueprintName Settings SettingsName ThemePackage Plan PlanName"
  },
  "library/theme-settings/theme-json.html": {
    "href": "library/theme-settings/theme-json.html",
    "title": "JSON Settings File | cre8magic",
    "keywords": "cre8magic  Magic Settings  JSON Settings File cre8magic uses JSON to enable fast and flexible configuration of your theme. It is used by Magic Settings to load all the initial information. This document explains the json file and everything you must know, such as: Special tricks to make work easier such as comments The general file format and sections Named configurations What can be configured in each section Special nodes which can accept string or more complex data Example JSON Here's a brief extract of such a configuration file (here's a live example): { // By specifying a schema we get intellisense in this JSON \"$schema\": \"https://2sic.github.io/cre8magic/schemas/2022-10/theme.json\", \"version\": 0.01, // Global debug settings \"debug\": { \"allowed\": true, // The most important setting - if this is false, nothing else will happen \"admin\": true, // Enable everywhere for admin \"anonymous\": true, // Enable everywhere for anonymous }, // Theme Configurations \"themes\": { // Default Theme - in most cases you'll just use this theme configuration \"Default\": { // Optional: Design Names with \"=\" mean they inherit / use the name already existing - in this case \"Default\" \"design\": \"=\", \"logo\": \"[Theme.Url]/assets/logo.svg\", \"languagesMin\": 1, \"parts\": { \"breadcrumbs\": true, // ...more stuff here... }, // Determins if we should use the body (or a div) for the magic context // As of now we feel that browser behavior is better if it's in the div-tag (false) \"magicContextInBody\": false, \"debug\": { \"admin\": true, } }, }, // ...more stuff here... } Special Tricks in the File The file will be parsed by .net, but we've activated some special features to make life easier: Comments are allowed Trailing commas are allowed Almost all node names are case insensitive, so \"Default\" and \"default\" are treated the same Make sure you add the \"$schema\" node as you see above, to get help and instructions editing the JSON General File Format and Sections Sections The theme-settings.json contains these primary nodes: version * (just version information) debug * for showing additional debug buttons on the page themes for the main settings of a specific theme such as Logo, breadcrumbs on/off, etc. themeDesigns has the configuration for CSS classes to be used in various places languages contains configuration for languages to show in the menu menus contains configuration for what menus show what nodes, like top-level with sub-level, etc. menuBlueprints contains a bunch of rules for how menus should be styled, such as classes to use on the active node etc. Named Configurations All of the nodes above (except those marked with *) can have many different, named configurations. So you'll see something like this: { \"themes\": { // The default configuration is taken if no other configuration is used \"Default\": { // ...stuff... }, // Alternate configuration for theme with menu on the side \"Sidebar\": { // ...stuff... }, } } This means that there is a configuration called Default and one called Sidebar which will do something different. @inherits Does Exactly What it Says Example from the menuBlueprints { \"mobile\": { \"ul\": { \"byLevel\": { \"1\": \"navbar-nav\", \"-1\": \"collapse theme-submenu-[Menu.Id]-[Page.Id]\" }, \"inBreadcrumb\": \"show\" }, \"li\": { \"classes\": \"nav-item nav-[Page.Id] position-relative\", \"hasChildren\": \"has-child\", \"isActive\": \"active\", \"isDisabled\": \"disabled\" }, \"a\": { \"classes\": \"nav-link mobile-navigation-link\", \"isActive\": \"active\" }, \"span\": { \"classes\": \"nav-item-sub-opener\", \"inBreadcrumb\": [ null, \"collapsed\" ] }, // Special target information (not really styling) usually on the span-tag \"data-bs-target\": \".theme-submenu-[Menu.Id]-[Page.Id]\" }, \"sidebar\": { \"@inherits\": \"Mobile\", \"a\": { // This is the only difference to Mobile \"classes\": \"nav-link\" } } } Short and Long Notations for True/False settings Most properties which indicate a binary true/false value like isActive or hasChildren can be configured two ways: \"isActive\": \"some-class-when-active\" \"isActive\": [\"active-class\", \"not-active-class\"] \"isActive\": [null, \"not-active-class\"] Short and Long Notations for Complex Objects Certain objects have a long notation, but can be shortened to just a string or bool if it's obvious what is meant. For example, the parts in the themes section would be: \"breadcrumbs\": { \"show\": true, \"design\": \"special-design-name\", \"configuration\": \"special-config-name\" } But this can be abbreviated to: \"breadcrumbs\": true - assumes show=true and design/configuration use the current name \"breadcrumbs\": \"name\" - assumes show=true and the design/config use the specified name This setup also works for all the design settings where you can do: \"container\": \"some string\" - in this case, classes/value get this, everyhing else is empty Intellisense using $schema To get help editing the file, add the $schema to your document. Your editor (at least VS Code) will then help you fill in everything you need. \"$schema\": \"https://2sic.github.io/cre8magic/schemas/2022-10/theme-configurations.schema.json\""
  },
  "magic-themes/index.html": {
    "href": "magic-themes/index.html",
    "title": "Magic Themes | cre8magic",
    "keywords": "Magic Themes TODO:"
  },
  "oqtane-themes-guide/index.html": {
    "href": "oqtane-themes-guide/index.html",
    "title": "Oqtane Blazor Theme Creation Guide | cre8magic",
    "keywords": "Oqtane Blazor Theme Creation Guide This guide will walk you through the process of creating a new theme for Oqtane. It will explain all the basics of how themes work and how to create them, and show you a bunch of tricks to make things better. Tip This guide is for developers who want to create a new theme for Oqtane. It's general purpose for all kinds of themes, not limited to cre8magic themes. Expected contents [home] what are themes, goals, etc. Create Your First Theme Walkthrough Create Theme (preparation etc.) Build Your First Theme How Themes Work Project Structure (Client, Shared, Server) Blazor & Blazor Components Theme Container ThemeInfo Panes Containers wwwroot Blazor Events Navigation ...Settings Packaging... Menus & Breadcrumbs Main Menu Footer Menu Side Menu Mobile Menu Breadcrumb Language Menu Floating To-Top Button Logos and Buttons Logo in Oqtane Theme Custom Edit / Settings Buttons Favicon Theme Components Create your own Use Library Theme JavaScripts Include Libraries / ensure startup Create your own Use TypeScript Mastering Bootstrap5 Background ...sass & Webpack Mastering Context and CSS Variations Analytics and GTM Oqtane Theme SEO Advanced Themes Multiple Themes and Containers Customizable Themes Inherit Blazor Component Theme Settings Upgrade Theme to New Oqtane Theme Distribution NuGet Package with libraries, dependencies etc. Install Theme Upgrade existing Theme"
  },
  "oqtane-themes-guide/parameters/index.html": {
    "href": "oqtane-themes-guide/parameters/index.html",
    "title": "Oqtane Blazor Theme Creation - Component Parameters Guide | cre8magic",
    "keywords": "Oqtane Blazor Theme Creation - Component Parameters Guide Blazor has a few secret tricks up its sleeve that can make your life easier when creating themes. A core challenge is passing parameters and settings around between components. Basics: 3 Ways to Pass Parameters There are 3 ways to pass parameters between components in Blazor: On a Component Attribute - the simplest way which you'll use a lot Cascade Parameters from Theme to any Control - Oqtane uses this a lot Using a Service Pass Parameters on a Component Attribute The simplest way to pass a parameter. Just add it to the attribute of the component. @* Example with a direct value *@ <MyComponent MyParameter=\"Hello World\" FavoriteNumber=\"42\" /> @* Example with a variable *@ @{ string myHello = \"Hello World\"; int myFavoriteNumber = 42; } <MyComponent MyParameter=\"@myHello\" FavoriteNumber=\"myFavoriteNumber\" /> Your component would then need to look a bit like this: @code { [Parameter] public string MyParameter { get; set; } [Parameter] public int FavoriteNumber { get; set; } } You can also tell the UI that this parameter is required, so that Visual Studio and the compiler will tell the developer that they need to provide it. @code { [Parameter, EditorRequired] public required string MyParameter { get; set; } } Tip It's not always clear (especially on strings) if the parameter should be the word myVariable or the contents of the variable myVariable. In most cases this is automatically deduced, but in cases of strings it can go wrong. When in doubt, use the @ symbol to tell Blazor to use the contents of the variable. You can also pass in larger objects, like a class or a list: @{ var myObject = new MyObject { Name = \"John\", Age = 42 }; var myListOfObjects = new List<MyObject> { myObject, myObject }; } <MyComponent MyObject=\"myObject\" MyListOfObjects=\"myListOfObjects\" /> The component would then look like this: @code { [Parameter] public MyObject MyObject { get; set; } [Parameter] public List<MyObject> MyListOfObjects { get; set; } } How Component Parameters are Used in Oqtane The Oqtane Framework won't give your components any data directly, so it won't pass in any parameters to your components like this. So this mechanism is mostly used for passing parameters between your components in your theme. Timing Issues with Component Parameters When you pass in a parameter to a component, it's not always available right away. This is because the component is initialized before the parameter is set, and sometimes the parent component is not yet ready to pass in the parameter. Some tips: always assume that the parameters could contain an empty / default value at first use the OnParametersSet or OnParametersSetAsync lifecycle methods to initialize other objects ... and to react to parameter changes when something else is initialized with this parameter, also assume that it could be empty at first Cascade Parameters from Theme to any Control Cascading parameters are a way to pass parameters down the component tree. This is useful when you have a lot of nested components and you don't want to pass the parameter through all of them. Imagine the following component tree: Theme Menu Component Menu Item Component Menu Icon Component Menu Item Menu Item This is what the Theme would look like: @{ var myObject = new IconSettings { Library = \"FontAwesome\" }; } <CascadingValue Value=\"myObject\"> <MyMenu /> </CascadingValue> And the MenuIcon Component would then look like this: @code { [CascadingParameter] public IconSettings MyIconSettings { get; set; } } This way you can pass the IconSettings object from the Theme to the MenuIcon Component without having to pass it through all the other components. Tip Cascading parameters are mapped using the Type of the object. This is why in the previous example we used a IconSettings object, even though we're just passing in as string value. How Cascading Parameters are Used in Oqtane Oqtane uses cascading parameters a lot. You will typically get the following parameters from the Theme: @code { /// <summary> /// Get the PageState from the CascadingParameter /// </summary> [CascadingParameter] public required PageState PageState { get; set; } } If your control is inside a module (eg. part of a Container) you can also get the ModuleState like this: @code { /// <summary> /// Get the ModuleState from the CascadingParameter /// </summary> [CascadingParameter] public required Module ModuleState { get; set; } } Timing Issues with Cascading Parameters Cascading parameters are set before the component is initialized, so you can be sure that they are available when the component is created. This is why you can use them to pass parameters to components that are not directly related to each other. Empty Values in Cascading Parameters Note that cascading parameters can be empty, because the parent component did not set them, or they were set to null or default by the parent component. So if you create your own cascading parameters, either mark them as required to get compiler errors, or do null/default checks in your component. Using a Service The last way to pass parameters is to use a service. This is a bit more advanced and not used as often as the other two ways. Services allow you to: pass parameters \"downwards\" in the component tree (like cascading parameters) pass parameters \"upwards\" in the component tree pass parameters \"sideways\" between components that are not directly related For this to work, a service needs to be scoped correctly, meaning that it should provide the same service instance for every component that needs it. This is done by registering the service as a scoped service in the Startup.cs file: namespace ToSic.Cre8magic; public class Startup : Oqtane.Services.IClientStartup { /// <summary> /// Register Services /// </summary> /// <param name=\"services\"></param> public void ConfigureServices(IServiceCollection services) { // All these Settings etc. should be scoped, so they don't have to reload for each click services.TryAddScoped<IMagicSettingsService, MagicSettingsService>(); } } Tip Scoped services have different behaviors depending on the RenderMode. For now, just understand that they will always give the same instance for everything that is rendered in the same page. Simple Example (Oqtane 5+) In Oqtane 5+ you can use the [Inject] attribute or @inject to inject services into your components. Tip This is the classic way of doing things, but has a few issues related to timing. Read on... Then you can use the service in your components like this: @code { [Inject] public IMagicSettingsService MagicSettingsService { get; set; } } or like this: @code @inject IMagicSettingsService MagicSettingsService In .net 9 you can also use constructor injection (new in Oqtane 6) which has some benefits: @code { private readonly IMagicSettingsService _magicSettingsService; public MyComponent(IMagicSettingsService magicSettingsService) { _magicSettingsService = magicSettingsService; } } Timing Issues with @inject and [Inject] Services Services injected with @inject or [Inject] are handled the same way, and they are not available when the component is constructed. Instead, they are available in the OnInitialized and OnInitializedAsync lifecycle method. This is important, because it's counterintuitive and different from the normal constructor injection that you might know from normal C# services. Either make sure your code expects this - or use constructor injection if you're on Oqtane 6. Constructor Injection (Oqtane 6+) In Oqtane 6+ you can use constructor injection to inject services into your components. Important Using Constructor Injection is a great way to avoid timing issues with services. It's also nicer but it has some downsides: You must separate your razor file into 2 files .razor and .razor.cs (with code behind) which is possibly not desired You can't easily inherit the component anymore (error CS7036: There is no argument given that corresponds to the required parameter...) So you can still inherit the component, but any descendant component must also use 2 razor files with code-behind, which is kind of viral... Tip Because of this tradeoff, we currently recommend against using constructor injection in Oqtane Components. How Service Injections are Used for Parameters in Oqtane This is about parameters in Oqtane, not about general Service Injection. In Oqtane, certain environment parameters are provided as a service instead of Cascading Parameters. Specifically, the SiteState is provided as a service: [Inject] protected SiteState SiteState { get; set; } This is because the SiteState will not change through the lifecycle of the page."
  },
  "oqtane-themes-guide/recommendations/blazor-debounce-strategies.html": {
    "href": "oqtane-themes-guide/recommendations/blazor-debounce-strategies.html",
    "title": "Debounce Strategies for Blazor | cre8magic",
    "keywords": "Debounce Strategies for Blazor todo: discuss options, eg. OnChange nullify OnChange set use inline variable"
  },
  "oqtane-themes-guide/recommendations/index.html": {
    "href": "oqtane-themes-guide/recommendations/index.html",
    "title": "Oqtane Theme Recommendations and Best Practices | cre8magic",
    "keywords": "Oqtane Theme Recommendations and Best Practices These are recommendations base on the cre8magic team's experience with Oqtane themes. We see these things as best practices, but they are not required, or may also be different from the official Oqtane Best Practices. Components should Inherit from ComponentBase, Not ThemeControlBase This applies to the many components you create in your theme, eg. for showing an icon, a menu, a breadcrumb, etc. It does not apply to the Theme itself, which should inherit from ThemeBase, or to Modules, which should inherit from ModuleBase. Do: Inherit from the standard ComponentBase This is in the Microsoft.AspNetCore.Components namespace. Your Component will usually require the Page-State, so you should add: @code { [CascadingParameter] public required PageState PageState { get; set; } } In some cases you may also need the Site-State or the Module-State. If you do need them, do this: @code { [Inject] public required SiteState SiteState { get; set; } [CascadingParameter] public required Module ModuleState { get; set; } } Don't: Inherit from ThemeControlBase The official way to create Components in Oqtane is to call them Controls and inherit from ThemeControlBase. Our Reasoning The ThemeControlBase is a custom class that is part of the Oqtane framework. This in turn inherits from ThemeBase which (IMHO) has various issues such as: It uses an Inheritance strategy instead of Composition, which we think is wrong. It mixes a lot of responsibilities It's huge and has a lot of APIs which we believe should not be used. In 99% of all cases all you need is the PageState, which you can get without this additional baggage. Doing this will also keep your code clean and more maintainable."
  }
}